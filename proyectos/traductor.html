<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pipeline completa para procesar PDFs con Python: extracción, limpieza, traducción e imágenes</title>
<meta name="description" content="Cómo construir una pipeline completa en Python para procesar PDFs: extraer texto, limpiar, traducir y extraer imágenes. Incluye código listo para usar." />
<style>
  * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
  }

  body {
      background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
      color: #e0e0e0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      min-height: 100vh;
      animation: gradientShift 8s ease-in-out infinite alternate;
  }

  @keyframes gradientShift {
      0% { background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%); }
      100% { background: linear-gradient(135deg, #0f0f0f 0%, #1e1e1e 100%); }
  }

  .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 56px 20px;
  }

  header {
      background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
      border-bottom: 1px solid #333;
      animation: headerGlow 4s ease-in-out infinite alternate;
  }

  @keyframes headerGlow {
      0% { box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4); }
      100% { box-shadow: 0 8px 32px rgba(187, 134, 252, 0.1); }
  }

  header .container {
      padding-top: 72px;
      padding-bottom: 72px;
  }

  h1 {
      font-size: 2.2rem;
      line-height: 1.2;
      margin: 0 0 10px 0;
      animation: titlePulse 3s ease-in-out infinite;
  }

  @keyframes titlePulse {
      0%, 100% { color: #ffffff; }
      50% { color: #bb86fc; }
  }

  h2 {
      font-size: 1.6rem;
      margin-top: 42px;
      border-top: 1px solid #333;
      padding-top: 28px;
      animation: headingShimmer 5s ease-in-out infinite;
  }

  @keyframes headingShimmer {
      0%, 100% { color: #bb86fc; }
      50% { color: #9d4edd; }
  }

  h3 {
      font-size: 1.2rem;
      margin-top: 28px;
      color: #bb86fc;
  }

  p {
      color: #e0e0e0;
      margin: 14px 0;
  }

  .lead {
      color: #a0a0a0;
      font-size: 1.05rem;
  }

  .card {
      background: rgba(30, 30, 30, 0.9);
      border: 1px solid #333;
      border-radius: 20px;
      padding: 22px;
      margin: 18px 0;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      border-left: 4px solid #bb86fc;
      transition: all 0.3s ease;
      animation: sectionFloat 6s ease-in-out infinite;
  }

  .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(187, 134, 252, 0.2);
  }

  @keyframes sectionFloat {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-1px); }
  }

  .toc {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 8px;
  }

  .toc a {
      display: block;
      background: rgba(30, 30, 30, 0.9);
      border: 1px solid #333;
      padding: 12px 14px;
      border-radius: 14px;
      transition: all 0.3s ease;
      animation: tocFloat 4s ease-in-out infinite;
  }

  .toc a:hover {
      background: rgba(187, 134, 252, 0.1);
      transform: translateY(-2px);
      border-color: #bb86fc;
  }

  @keyframes tocFloat {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-1px); }
  }

  code, pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      animation: codeGlow 2s ease-in-out infinite alternate;
  }

  @keyframes codeGlow {
      0% { box-shadow: 0 0 5px rgba(244, 67, 54, 0.3); }
      100% { box-shadow: 0 0 10px rgba(244, 67, 54, 0.5); }
  }

  pre {
      background: #2d2d2d;
      color: #f8f8f2;
      border: 1px solid #444;
      border-radius: 16px;
      padding: 16px;
      overflow: auto;
      transition: all 0.3s ease;
  }

  pre:hover {
      background: #333;
      border-color: #bb86fc;
  }

  code {
      background: #2d2d2d;
      color: #f44336;
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid #444;
  }

  .kbd {
      display: inline-block;
      background: #2d2d2d;
      border: 1px solid #444;
      padding: 2px 6px;
      border-radius: 6px;
      animation: kbdGlow 2s ease-in-out infinite;
  }

  @keyframes kbdGlow {
      0%, 100% { background: #2d2d2d; }
      50% { background: #3a3a3a; }
  }

  ul {
      padding-left: 22px;
  }

  .footer {
      color: #a0a0a0;
      font-size: .9rem;
      margin-top: 48px;
      padding-top: 24px;
      border-top: 1px dashed #333;
  }

  .tag {
      display: inline-block;
      font-size: .8rem;
      color: #0c0c0c;
      background: #bb86fc;
      padding: 2px 8px;
      border-radius: 999px;
      margin-right: 6px;
      animation: tagPulse 2s ease-in-out infinite;
  }

  @keyframes tagPulse {
      0%, 100% { background: #bb86fc; }
      50% { background: #9d4edd; }
  }

  .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 14px;
  }

  a {
      color: #bb86fc;
      text-decoration: none;
      transition: all 0.3s ease;
  }

  a:hover {
      color: #9d4edd;
      text-decoration: underline;
  }

  .full-script {
      background: #2d2d2d;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      overflow-x: auto;
      font-family: 'Courier New', monospace;
      color: #f8f8f2;
      font-size: 0.85rem;
      line-height: 1.4;
      max-height: 600px;
      overflow-y: auto;
      transition: all 0.3s ease;
  }

  .full-script:hover {
      background: #333;
      border-color: #bb86fc;
  }

  .full-script::-webkit-scrollbar {
      width: 12px;
      height: 12px;
  }

  .full-script::-webkit-scrollbar-track {
      background: #2c2c2c;
  }

  .full-script::-webkit-scrollbar-thumb {
      background: #bb86fc;
      border-radius: 6px;
  }

  .full-script::-webkit-scrollbar-thumb:hover {
      background: #9d4edd;
  }

  .python-keyword { color: #66d9ef; animation: keywordGlow 4s ease-in-out infinite; }
  .python-string { color: #a6e22e; animation: stringGlow 3s ease-in-out infinite; }
  .python-comment { color: #75715e; }
  .python-function { color: #f92672; animation: functionGlow 5s ease-in-out infinite; }
  .python-number { color: #ae81ff; animation: numberGlow 2s ease-in-out infinite; }

  @keyframes keywordGlow { 0%, 100% { color: #66d9ef; } 50% { color: #4fc3f7; } }
  @keyframes stringGlow { 0%, 100% { color: #a6e22e; } 50% { color: #c8e6c9; } }
  @keyframes functionGlow { 0%, 100% { color: #f92672; } 50% { color: #ff6b8a; } }
  @keyframes numberGlow { 0%, 100% { color: #ae81ff; } 50% { color: #ce93d8; } }
</style>
</head>
<body>
  <header>
    <div class="container">
      <span class="tag">Python</span>
      <span class="tag">PDF</span>
      <span class="tag">IA Local</span>
      <h1>Procesamiento completo de PDFs con Python: extracción, limpieza, traducción y exportación de imágenes</h1>
      <p class="lead">Construye una pipeline práctica para trabajar con documentos PDF: separa y guarda el texto por página, limpia saltos innecesarios, traduce de forma automática con Ollama y exporta todas las imágenes incrustadas.</p>
    </div>
  </header>

  <main class="container">
    <div class="card">
      <h2 id="resumen">Resumen</h2>
      <p>En este artículo implementamos una solución integral para procesar PDFs en cuatro etapas:</p>
      <ol>
        <li><strong>Extracción de texto</strong> por página con <span class="kbd">PyPDF2</span>.</li>
        <li><strong>Limpieza</strong> de saltos de línea y normalización con <span class="kbd">re</span>.</li>
        <li><strong>Traducción</strong> del inglés al español usando <span class="kbd">Ollama</span> y un modelo local (<span class="kbd">llama3.1:8b</span>).</li>
        <li><strong>Extracción de imágenes</strong> incrustadas con <span class="kbd">PyMuPDF / fitz</span>.</li>
      </ol>
      <div class="grid">
        <div>
          <h3>Requisitos</h3>
          <pre><code class="language-bash">pip install PyPDF2 pymupdf ollama</code></pre>
          <p>Además, instala y levanta <a href="https://ollama.com" target="_blank" rel="noopener">Ollama</a> y ten disponible el modelo <span class="kbd">llama3.1:8b</span>.</p>
        </div>
        <div>
          <h3>Estructura de carpetas (resultado)</h3>
          <pre><code class="language-text">./paginas/              # Texto por página (crudo)
./paginas_limpias/      # Texto limpio
./paginas_traducidas/   # Texto traducido
./imagen_pdf/           # Imágenes extraídas</code></pre>
        </div>
      </div>
    </div>

    <div class="card">
      <h2 id="toc">Índice</h2>
      <nav class="toc">
        <a href="#paso1">Paso 1 · Extraer texto con PyPDF2</a>
        <a href="#paso2">Paso 2 · Limpiar y normalizar texto</a>
        <a href="#paso3">Paso 3 · Traducir con Ollama</a>
        <a href="#paso4">Paso 4 · Extraer imágenes con PyMuPDF</a>
        <a href="#mejoras">Mejoras y buenas prácticas</a>
      </nav>
    </div>

    <section class="card" id="paso1">
      <h2>Paso 1 · Extraer texto con PyPDF2</h2>
      <p>Extraemos el texto de cada página y lo guardamos en archivos <span class="kbd">.txt</span> independientes dentro de <span class="kbd">./paginas</span>.</p>
      <pre><code class="language-python">import PyPDF2
import os


def crearTxt(numero: int, texto: str) -&gt; bool:
    &quot;&quot;&quot;
    Crea un archivo de texto con el contenido dado.

    Args:
        numero (int): El número de página para el nombre del archivo.
        texto (str): El texto a escribir en el archivo.

    Returns:
        bool: True si el archivo se creó correctamente.
    &quot;&quot;&quot;
    with open(f'./paginas/{numero}.txt', 'w', encoding='utf-8') as f:
        f.write(texto)
    return True


def extraerTexto(pdf: str) -&gt; str:
    &quot;&quot;&quot;
    Extrae el texto de un archivo PDF y lo guarda en archivos de texto individuales.

    Args:
        pdf (str): La ruta al archivo PDF.

    Returns:
        str: El texto concatenado de todas las páginas del PDF.
    &quot;&quot;&quot;
    texto = ''
    contador = 1
    with open(pdf, 'rb') as f:
        pdf_reader = PyPDF2.PdfReader(f)
        for page in pdf_reader.pages:
            texto_pagina = page.extract_text()
            crearTxt(contador, texto_pagina)
            texto += texto_pagina
            contador += 1
    return texto


def main():
    &quot;&quot;&quot;
    Función principal del programa.
    Extrae el texto de un PDF y lo guarda en archivos de texto.
    &quot;&quot;&quot;
    pdf = 'a-christmas-carol-charles-dickens.pdf'
    extraerTexto(pdf)


if __name__ == '__main__':
    main()</code></pre>
      <p><strong>Salida esperada:</strong> archivos numerados <span class="kbd">1.txt</span>, <span class="kbd">2.txt</span>, … en <span class="kbd">./paginas</span>.</p>
    </section>

    <section class="card" id="paso2">
      <h2>Paso 2 · Limpiar y normalizar texto</h2>
      <p>Eliminamos saltos de línea problemáticos y conservamos una versión más legible en <span class="kbd">./paginas_limpias</span>.</p>
      <pre><code class="language-python">import os
import re

RUTA_ORIGEN = './paginas'
RUTA_DESTINO = './paginas_limpias'


os.makedirs(RUTA_DESTINO, exist_ok=True)


def guardarTexto(texto: str, nombre_archivo: str) -&gt; None:
    &quot;&quot;&quot;
    Guarda el texto en un archivo.

    Args:
        texto (str): El texto a guardar.
        nombre_archivo (str): El nombre del archivo.
    &quot;&quot;&quot;
    with open(os.path.join(RUTA_DESTINO, nombre_archivo), 'w', encoding='utf-8') as f:
        f.write(texto)
def limparTexto(texto: str, file: str) -&gt; None:
    &quot;&quot;&quot;
    Limpia el texto eliminando saltos de línea innecesarios y guarda el resultado.

    Args:
        texto (str): El texto a limpiar.
        file (str): El nombre del archivo.
    &quot;&quot;&quot;
    texto = re.sub(r&quot; \n&quot;, &quot; &quot;, texto)
    guardarTexto(texto, file)


def main():
    &quot;&quot;&quot;
    Función principal del programa.
    Recorre los archivos de texto en la ruta de origen, los limpia y los guarda en la ruta de destino.
    &quot;&quot;&quot;
    for root, _, files in os.walk(RUTA_ORIGEN):
        for file in files:
            if file.endswith('.txt'):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    texto = f.read()
                    limparTexto(texto, file)


if __name__ == '__main__':
    main()</code></pre>
      <p><strong>Salida esperada:</strong> mismos nombres de archivo, pero en <span class="kbd">./paginas_limpias</span>.</p>
    </section>

    <section class="card" id="paso3">
      <h2>Paso 3 · Traducir con Ollama</h2>
      <p>Traducimos línea por línea usando el modelo local <span class="kbd">llama3.1:8b</span> con <span class="kbd">Ollama</span>, y guardamos el resultado en <span class="kbd">./paginas_traducidas</span>.</p>
      <pre><code class="language-python">import os
import ollama

RUTA_ORIGEN = './paginas_limpias'
RUTA_DESTINO = './paginas_traducidas'

os.makedirs(RUTA_DESTINO, exist_ok=True)


def traducir(texto: str) -&gt; str:
    &quot;&quot;&quot;
    Traduce un texto del inglés al español utilizando el modelo de Ollama.

    Args:
        texto (str): El texto a traducir.

    Returns:
        str: El texto traducido.
    &quot;&quot;&quot;
    response = ollama.chat(
        model='llama3.1:8b',
        messages=[
            {
                'role': 'user',
                'content': 'Te voy a proporciona un texto para traducir del ingles al espanol. Solo traduce. No respondas ni hagas comentarios. El texto es posible que contenga errores o fragmentos de codigo. En ese caso, ignora los mismos.' + texto,
            },
        ],
    )
    return response['message']['content']


def main():
    &quot;&quot;&quot;
    Función principal del programa.
    Recorre los archivos de texto en la ruta de origen, los traduce y los guarda en la ruta de destino.
    &quot;&quot;&quot;
    for root, _, files in os.walk(RUTA_ORIGEN):
        for file in files:
            texto_a_insertar = &quot;&quot;
            if file.endswith('.txt'):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    texto = f.readlines()
                    for linea in texto:
                        traduccion = traducir(linea)
                        texto_a_insertar += traduccion

                with open(os.path.join(RUTA_DESTINO, file), 'w', encoding='utf-8') as f:
                    f.write(texto_a_insertar)


if __name__ == '__main__':
    main()</code></pre>
      <p><strong>Salida esperada:</strong> un archivo traducido por cada entrada en <span class="kbd">./paginas_traducidas</span>.</p>
    </section>

    <section class="card" id="paso4">
      <h2>Paso 4 · Extraer imágenes con PyMuPDF (fitz)</h2>
      <p>Exportamos todas las imágenes incrustadas del PDF a <span class="kbd">.png</span>, guardándolas en <span class="kbd">./imagen_pdf</span>.</p>
      <pre><code class="language-python">import fitz
import os

RUTA_DESTINO_IMAGENES = './imagen_pdf'

os.makedirs(RUTA_DESTINO_IMAGENES, exist_ok=True)


def extraerImagenesPdf(pdf: str) -&gt; None:
    &quot;&quot;&quot;
    Extrae las imágenes de un archivo PDF y las guarda como archivos PNG.

    Args:
        pdf (str): La ruta al archivo PDF.
    &quot;&quot;&quot;
    pdf_document = fitz.open(pdf)
    for page_index in range(len(pdf_document)):
        page = pdf_document[page_index]
        image_list = page.get_images()
        for image_index, img in enumerate(image_list, start=1):
            xref = img[0]
            base_image = pdf_document.extract_image(xref)
            image_data = base_image[&quot;image&quot;]
            if len(image_list) &gt; 1:
                nombre_archivo = f&quot;imagen_{page_index}_{image_index}.png&quot;
            else:
                nombre_archivo = f&quot;imagen_{page_index}.png&quot;
            ruta_archivo = os.path.join(RUTA_DESTINO_IMAGENES, nombre_archivo)
            with open(ruta_archivo, &quot;wb&quot;) as fp:
                fp.write(image_data)


def main():
    &quot;&quot;&quot;
    Función principal del programa.
    Extrae las imágenes de un PDF específico.
    &quot;&quot;&quot;
    extraerImagenesPdf(&quot;Deep Reinforcement Learning with Python (2024).pdf&quot;)


if __name__ == &quot;__main__&quot;:
    main()</code></pre>
      <p><strong>Salida esperada:</strong> un conjunto de archivos <span class="kbd">PNG</span> por cada página o imagen encontrada.</p>
    </section>

    <section class="card" id="mejoras">
      <h2>Mejoras y buenas prácticas</h2>
      <ul>
        <li>Verificar la existencia de las carpetas de salida antes de escribir (ya cubierto con <span class="kbd">os.makedirs(..., exist_ok=True)</span>).</li>
        <li>Manejar PDFs con páginas que contienen solo imágenes (la extracción de texto puede devolver <span class="kbd">None</span>).</li>
        <li>Agregar <em>logging</em> y manejo de excepciones para diagnósticos en producción.</li>
        <li>Permitir parámetros por CLI: rutas de entrada/salida, nombre de archivo PDF, modelo de traducción, etc.</li>
        <li>Unir páginas en un solo archivo final si se desea una salida consolidada post-limpieza o post-traducción.</li>
      </ul>
    </section>

    <p style="text-align: center; margin-top: 20px; animation: linkGlow 2s ease-in-out infinite;">
        <a href="https://github.com/bgonpin/TraductorIA" target="_blank" rel="noopener">Repositorio del proyecto en GitHub</a>
    </p>
    <p class="footer" style="text-align: center;">
        <a href="../proyectos/proyectos.html">Volver a todos los proyectos</a>
    </p>
  </main>
</body>
</html>
