<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manual de Empleo - Organizador de Im√°genes y Extractor de Metadatos</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: #2b2b2b;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            color: #e0e0e0;
        }
        h1, h2, h3 {
            color: #ffffff;
        }
        h1 {
            border-bottom: 3px solid #005a9e;
            padding-bottom: 10px;
        }
        h2 {
            border-bottom: 2px solid #005a9e;
            padding-bottom: 5px;
            margin-top: 40px;
            color: #ffffff;
        }
        h3 {
            color: #ffffff;
        }
        .code {
            background: #1e1e1e;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #ffffff;
        }
        .requirements {
            background: #2d3748;
            border-left: 4px solid #005a9e;
            padding: 15px;
            margin: 20px 0;
            color: #e0e0e0;
        }
        .warning {
            background: #4a3c00;
            border-left: 4px solid #8b7300;
            padding: 15px;
            margin: 20px 0;
            color: #fff3cd;
        }
        .step {
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            color: #e0e0e0;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
            color: #e0e0e0;
        }
        li {
            margin-bottom: 5px;
            color: #e0e0e0;
        }
        a {
            color: #007cba;
            text-decoration: none;
        }
        a:hover {
            color: #005a9e;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        table th, table td {
            padding: 8px;
            border: 1px solid #555;
            color: #e0e0e0;
        }
        table th {
            background-color: #005a9e;
            color: white;
        }
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            border-top: 3px solid #005a9e;
            color: #e0e0e0;
        }
        pre {
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Manual de Empleo - Organizador de Im√°genes y Extractor de Metadatos</h1>

        <section id="introduccion">
            <h2>1. Introducci√≥n</h2>
            <p>Este proyecto es un organizador fotogr√°fico avanzado que procesa im√°genes, extrae metadatos y los almacena en una base de datos MongoDB. El sistema consta de varios m√≥dulos que se ejecutan en un orden espec√≠fico para procesar la colecci√≥n completa de im√°genes.</p>

            <p><strong>Funcionalidades principales:</strong></p>
            <ul>
                <li>Actualizaci√≥n de IDs en MongoDB usando hashes SHA-512</li>
                <li>Alimentaci√≥n de la base de datos con metadatos b√°sicos de im√°genes</li>
                <li>Extracci√≥n de informaci√≥n XMP para personas tierra identificadas en las fotos</li>
                <li>Generaci√≥n de estad√≠sticas completas sobre los metadatos procesados</li>
            </ul>

            <p style="margin-top: 20px;"><strong>Nota sobre procesamiento facial y metadatos:</strong> La detecci√≥n facial y la inserci√≥n de metadatos en los archivos se ha realizado con la aplicaci√≥n <a href="picasa3_tutorial_html.html" target="_blank">Picasa 3 de Google</a>. Para m√°s informaci√≥n detallada sobre el uso de Picasa 3, consulte el <a href="picasa3_tutorial_html.html" target="_blank">tutorial dedicado</a>.</p>

            <div class="warning">
                <strong>Importante:</strong> Los scripts deben ejecutarse en el orden establecido por los n√∫meros de carpetas para garantizar el correcto funcionamiento del sistema.
            </div>
        </section>

        <section id="descarga-proyecto">
            <h2>2. Descarga del Proyecto</h2>
            <p>El c√≥digo fuente completo del proyecto de organizaci√≥n de im√°genes se encuentra disponible para descarga:</p>

            <div class="requirements">
                <h3>Archivo del Proyecto:</h3>
                <ul>
                    <li><strong>Nombre:</strong> ALBUM_SEMANTICO.zip</li>
                    <li><strong>Ubicaci√≥n:</strong> Carpeta <code>codigo/</code></li>
                    <li><strong>Contenido:</strong> Todos los scripts Python organizados por m√≥dulos</li>
                </ul>

                <p><a href="https://bgonpin.github.io/codigo/ALBUM_SEMANTICO.zip" download class="download-link" style="display: inline-block; background-color: #005a9e; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; font-weight: bold;">Descargar Proyecto (ALBUM_SEMANTICO.zip)</a></p>

                <p><strong>Instrucciones de descarga:</strong></p>
                <ol>
                    <li>Haz clic en el enlace de descarga anterior</li>
                    <li>Guarda el archivo ZIP en tu sistema local</li>
                    <li>Extrae el contenido del archivo ZIP</li>
                    <li>Sigue las instrucciones de este manual para configurar y ejecutar los scripts</li>
                </ol>
            </div>
        </section>

        <section id="estructura-proyecto">
            <h2>2. Estructura del Proyecto</h2>

            <div class="requirements">
                <h3>Estructura de Carpetas:</h3>
                <pre style="background-color: #2d3748; color: #e2e8f0; padding: 20px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 14px; overflow-x: auto;">
üìÅ ALBUM_SEMANTICO/
‚îú‚îÄ‚îÄ üìÅ 1_ACTUALIZAR_ID_MONGODB/
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ actualizar_ids_mongodb_imagenes.py
‚îú‚îÄ‚îÄ üìÅ 2_ALIMENTAR_BD/
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ =0.10.0  (especificaci√≥n de versi√≥n)
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ =1.7.3   (especificaci√≥n de versi√≥n)
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ =1.9.0   (especificaci√≥n de versi√≥n)
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ =1.18.1  (especificaci√≥n de versi√≥n)
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ =3.4.3   (especificaci√≥n de versi√≥n)
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ =4.1.2   (especificaci√≥n de versi√≥n)
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ =7.0.0   (especificaci√≥n de versi√≥n)
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ 1-alimentar.py
‚îú‚îÄ‚îÄ üìÅ 3_EXTRAER_XMP/
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ 1_extraer_xmp_a_mongodb .py
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ 2_extraer_todos_metadatos_a_mongodb.py
‚îú‚îÄ‚îÄ üìÅ GENERAR_ESTADISTICAS_MONGODB/
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ generar_estadisticas_mongodb.py
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ requirements.txt
‚îî‚îÄ‚îÄ üìÑ manual_empleo.html  (este archivo de documentaci√≥n)
                </pre>

                <h3>Descripci√≥n de Archivos por Carpeta:</h3>

                <div class="step">
                    <h4>üìÅ 1_ACTUALIZAR_ID_MONGODB/</h4>
                    <ul>
                        <li><strong>M√≥dulo 1:</strong> Actualizaci√≥n de IDs</li>
                        <li><strong>Funci√≥n principal:</strong> Garantizar integridad de datos usando hashes SHA-512</li>
                        <li><code>actualizar_ids_mongodb_imagenes.py</code> - Script principal del m√≥dulo</li>
                    </ul>
                </div>

                <div class="step">
                    <h4>üìÅ 2_ALIMENTAR_BD/</h4>
                    <ul>
                        <li><strong>M√≥dulo 2:</strong> Alimentaci√≥n de base de datos</li>
                        <li><strong>Funci√≥n principal:</strong> Escanear directorio y extraer metadatos b√°sicos</li>
                        <li><code>1-alimentar.py</code> - Script principal del m√≥dulo</li>
                        <li><code>=X.X.X</code> - Archivos de especificaci√≥n de versiones de dependencias</li>
                    </ul>
                </div>

                <div class="step">
                    <h4>üìÅ 3_EXTRAER_XMP/</h4>
                    <ul>
                        <li><strong>M√≥dulo 3:</strong> Extracci√≥n de metadatos XMP</li>
                        <li><strong>Funci√≥n principal:</strong> Procesar metadatos avanzados de im√°genes</li>
                        <li><code>1_extraer_xmp_a_mongodb .py</code> - Script para extraer nombres de personas</li>
                        <li><code>2_extraer_todos_metadatos_a_mongodb.py</code> - Script para extraer todos los metadatos XMP/EXIF</li>
                    </ul>
                </div>

                <div class="step">
                    <h4>üìÅ GENERAR_ESTADISTICAS_MONGODB/</h4>
                    <ul>
                        <li><strong>M√≥dulo 4 (Opcional):</strong> Generador de estad√≠sticas</li>
                        <li><strong>Funci√≥n principal:</strong> An√°lisis estad√≠stico de datos procesados</li>
                        <li><code>generar_estadisticas_mongodb.py</code> - Script principal del m√≥dulo</li>
                        <li><code>requirements.txt</code> - Archivo de dependencias espec√≠ficas</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="requisitos-generales">
            <h2>3. Requisitos Generales</h2>

            <div class="requirements">
                <h3>Sistema Requerido</h3>
                <ul>
                    <li><strong>MongoDB</strong> instalado y ejecut√°ndose (por defecto en mongodb://localhost:27017)</li>
                    <li><strong>Python 3.7+</strong> instalado</li>
                    <li>Im√°genes con formatos soportados: JPG, JPEG, PNG, GIF, BMP, TIFF, WEBP, HEIC</li>
                </ul>

                <h3>Dependencias Python</h3>
                <ul>
                    <li><code>pymongo</code> - Para conexi√≥n con MongoDB</li>
                    <li><code>pandas</code> - Para procesamiento de datos (solo para estad√≠sticas)</li>
                    <li><code>colorama</code> - Para salida coloreada (opcional, solo para estad√≠sticas)</li>
                    <li><code>PIL (Pillow)</code> - Para procesamiento de im√°genes</li>
                    <li><code>exifread</code> - Para lectura de metadatos EXIF</li>
                    <li><code>requests</code> - Para geocodificaci√≥n</li>
                    <li><code>pyexiv2</code> - Para procesamiento de metadatos XMP</li>
                </ul>

                <p><strong>Instalaci√≥n de dependencias:</strong></p>
                <div class="code">pip install pymongo pillow exifread requests pyexiv2 pandas colorama</div>

                <h3>Configuraci√≥n de Variables de Entorno (Opcional)</h3>
                <ul>
                    <li><code>MONGO_URI</code> - URI de conexi√≥n a MongoDB</li>
                    <li><code>DB_NAME</code> - Nombre de la base de datos</li>
                    <li><code>COLLECTION_NAME</code> - Nombre de la colecci√≥n principal</li>
                    <li><code>MONGODB_URI</code> - URL de MongoDB para el generador de estad√≠sticas</li>
                    <li><code>DATABASE_NAME</code> - Base de datos para estad√≠sticas</li>
                    <li><code>COLLECTION_NAME</code> - Colecci√≥n para estad√≠sticas</li>
                </ul>
            </div>
        </section>

        <section id="estructura-bases-datos">
            <h2>4. Estructura de Bases de Datos</h2>

            <div class="requirements">
                <h3>Arquitectura General de MongoDB:</h3>
                <div class="code">Database: album (por defecto) / your_database_name</div>

                <h3>Colecciones Principales:</h3>

                <div class="step">
                    <h4>üìö Collection: imagenes_collection / target_collection</h4>
                    <p><strong>Prop√≥sito:</strong> Almacena toda la informaci√≥n b√°sica de im√°genes procesadas</p>
                    <h5>Estructura del Documento:</h5>
                    <pre style="background-color: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 13px; overflow-x: auto;">
{
  "_id": "hash_sha512_de_la_imagen",  // √çndice √∫nico (SHA-512 del archivo)
  "hash_sha512": "string",            // Hash del archivo completo
  "ruta": "string",                   // Ruta completa al archivo
  "nombre": "string",                 // Nombre del archivo

  // Metadatos de imagen
  "ancho": number,                    // Ancho en p√≠xeles
  "alto": number,                     // Alto en p√≠xeles
  "peso": number,                     // Tama√±o en KB

  // Fecha de creaci√≥n del archivo (componentes separados)
  "fecha_creacion_dia": "DD",
  "fecha_creacion_mes": "MM",
  "fecha_creacion_anio": "YYYY",
  "fecha_creacion_hora": "HH",
  "fecha_creacion_minuto": "MM",

  // Informaci√≥n de ubicaci√≥n GPS
  "coordenadas": [lat, lng],          // Array con coordenadas decimales
  "calle": "string",                  // Calle geocodificada
  "barrio": "string",                 // Barrio geocodificado
  "ciudad": "string",                 // Ciudad geocodificada
  "cp": "string",                     // C√≥digo postal
  "pais": "string",                   // Pa√≠s geocodificado

  // Fecha de procesamiento (examen autom√°tico)
  "fecha_procesamiento_dia": "DD",
  "fecha_procesamiento_mes": "MM",
  "fecha_procesamiento_anio": "YYYY",
  "fecha_procesamiento_hora": "HH",
  "fecha_procesamiento_minuto": "MM",

  // Array de personas identificadas (m√≥dulo 3)
  "personas": ["string"],             // Array de nombres de personas

  // Campo opcional para procesamiento adicional
  "objeto_procesado": boolean,        // Estado de procesamiento
  "objetos": ["string"],              // Array de objetos detectados
  "ruta_alternativa": "string"        // Ruta alternativa del archivo
}
                    </pre>
                </div>

                <div class="step">
                    <h4>üìÅ Collection: target_metadata_collection</h4>
                    <p><strong>Prop√≥sito:</strong> Almacena todos los metadatos XMP y EXIF avanzados</p>
                    <h5>Estructura del Documento:</h5>
                    <pre style="background-color: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 13px; overflow-x: auto;">
{
  "_id": ObjectId(),                  // ID autom√°tico de MongoDB
  "ruta_imagen": "string",            // Ruta completa al archivo original
  "fecha_extraccion": "YYYY-MM-DD HH:MM:SS", // Cuando se extrajeron los metadatos

  // Metadatos XMP (extensibles)
  "Xmp.xmp.CreateDate": "string",     // Fecha de creaci√≥n XMP
  "Xmp.xmp.MetadataDate": "string",   // Fecha de metadatos
  "Xmp.xmp.CreatorTool": "string",    // Herramienta creadora
  "Xmp.xmp.Label": "string",          // Etiqueta XMP
  "Xmp.mwg-rs.Regions/mwg-rs:RegionList[i]/mwg-rs:Name": "string", // Nombres de regiones
  "Xmp.mwg-rs.Regions/mwg-rs:RegionList[i]/mwg-rs:Area": {
    "mwg-rs:x": number,
    "mwg-rs:y": number,
    "mwg-rs:w": number,
    "mwg-rs:h": number
  },

  // Ejemplos de metadatos EXIF (extensibles)
  "Exif.Image.Make": "string",        // Fabricante de la c√°mara
  "Exif.Image.Model": "string",       // Modelo de la c√°mara
  "Exif.Image.Software": "string",    // Software usado
  "Exif.Image.DateTime": "string",    // Fecha y hora EXIF
  "Exif.Image.Orientation": number,   // Orientaci√≥n de la imagen
  "Exif.Photo.ExposureTime": number,  // Tiempo de exposici√≥n
  "Exif.Photo.FNumber": "f/number",   // N√∫mero F
  "Exif.Photo.ISOSpeedRatings": number, // ISO
  "Exif.Photo.FocalLength": number,   // Longitud focal
  "Exif.GPSInfo.GPSLatitude": "DD MM SS", // Latitud GPS
  "Exif.GPSInfo.GPSLongitude": "DD MM SS", // Longitud GPS
  "Exif.GPSInfo.GPSLatitudeRef": "N/S",   // Referencia latitud
  "Exif.GPSInfo.GPSLongitudeRef": "E/W",   // Referencia longitud

  // M√°s campos XMP/EXIF seg√∫n disponibilidad...
}
                    </pre>
                    <p><em><strong>Nota:</strong> Esta colecci√≥n contiene todos los metadatos XMP y EXIF encontrados. Los campos son din√°micos seg√∫n el contenido de cada imagen.</em></p>
                </div>

                <div class="step">
                    <h4>üìä Collection: imagenes_2</h4>
                    <p><strong>Prop√≥sito:</strong> Colecci√≥n analizada por el generador de estad√≠sticas</p>
                    <p><em>Utilizada por el M√≥dulo 4 para generar reportes estad√≠sticos detallados.</em></p>
                </div>

                <h3>Configuraci√≥n por Variables de Entorno:</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                    <thead>
                        <tr style="background-color: #007cba; color: white;">
                            <th style="padding: 8px; border: 1px solid #ddd;">Variable</th>
                            <th style="padding: 8px; border: 1px solid #ddd;">Valor por Defecto</th>
                            <th style="padding: 8px; border: 1px solid #ddd;">Prop√≥sito</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #ddd;"><code>MONGO_URI</code></td>
                            <td style="padding: 8px; border: 1px solid #ddd;"><code>mongodb://localhost:27017</code></td>
                            <td style="padding: 8px; border: 1px solid #ddd;">URI de conexi√≥n a MongoDB</td>
                        </tr>
                        <tr style="background-color: #f8f9fa;">
                            <td style="padding: 8px; border: 1px solid #ddd;"><code>DB_NAME</code></td>
                            <td style="padding: 8px; border: 1px solid #ddd;"><code>your_database_name</code></td>
                            <td style="padding: 8px; border: 1px solid #ddd;">Nombre de la base de datos</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #ddd;"><code>COLLECTION_NAME</code></td>
                            <td style="padding: 8px; border: 1px solid #ddd;"><code>your_collection_name</code></td>
                            <td style="padding: 8px; border: 1px solid #ddd;">Nombre de la colecci√≥n principal</td>
                        </tr>
                        <tr style="background-color: #f8f9fa;">
                            <td style="padding: 8px; border: 1px solid #ddd;"><code>MONGODB_URI</code></td>
                            <td style="padding: 8px; border: 1px solid #ddd;"><code>mongodb://localhost:27017/</code></td>
                            <td style="padding: 8px; border: 1px solid #ddd;">URI alternativo para estad√≠sticas</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #ddd;"><code>DATABASE_NAME</code></td>
                            <td style="padding: 8px; border: 1px solid #ddd;"><code>album</code></td>
                            <td style="padding: 8px; border: 1px solid #ddd;">Base de datos para estad√≠sticas</td>
                        </tr>
                        <tr style="background-color: #f8f9fa;">
                            <td style="padding: 8px; border: 1px solid #ddd;"><code>COLLECTION_NAME</code></td>
                            <td style="padding: 8px; border: 1px solid #ddd;"><code>imagenes_2</code></td>
                            <td style="padding: 8px; border: 1px solid #ddd;">Colecci√≥n para estad√≠sticas</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Relaciones entre Colecciones:</h3>
                <div class="warning">
                    <strong>Flujo de Trabajo:</strong>
                    <ol>
                        <li>Los scripts actualizan/crean documentos en <code>imagenes_collection</code> o <code>target_collection</code></li>
                        <li>Los metadatos adicionales se guardan en <code>target_metadata_collection</code></li>
                        <li>Las estad√≠sticas se generan desde <code>imagenes_2</code></li>
                    </ol>
                </div>

                <h3>√çndices Recomendados (Performance):</h3>
                <ul>
                    <li><code>{ "_id": 1 }</code> - √çndice √∫nico autom√°tico de MongoDB</li>
                    <li><code>{ "ruta": 1 }</code> - Para b√∫squeda r√°pida por archivo</li>
                    <li><code>{ "hash_sha512": 1 }</code> - Para detecci√≥n de duplicados</li>
                    <li><code>{ "fecha_procesamiento": 1 }</code> - Para ordenamiento temporal</li>
                    <li><code>{ "coordenadas": 1 }</code> - Para consultas geoespaciales</li>
                    <li><code>{ "ruta_imagen": 1 }</code> - Para metadatos (colecci√≥n metadata)</li>
                </ul>
            </div>
        </section>

        <section id="orden-ejecucion">
            <h2>5. Orden de Ejecuci√≥n de M√≥dulos</h2>
            <p>Los m√≥dulos deben ejecutarse en el siguiente orden para garantizar el correcto procesamiento de los datos:</p>

            <div class="step">
                <h3>1. Actualizaci√≥n de IDs MongoDB</h3>
                <p>Ubicaci√≥n: <code>1_ACTUALIZAR_ID_MONGODB/actualizar_ids_mongodb_imagenes.py</code></p>
                <p><strong>Prop√≥sito:</strong> Calcula hashes SHA-512 de las im√°genes y los utiliza como IDs √∫nicos en MongoDB, evitando duplicados.</p>
                <p><strong>¬øCu√°ndo ejecutar?</strong> Este script es fundamental para garantizar la integridad de los datos antes de cualquier procesamiento.</p>
            </div>

            <div class="step">
                <h3>2. Alimentaci√≥n de la Base de Datos</h3>
                <p>Ubicaci√≥n: <code>2_ALIMENTAR_BD/1-alimentar.py</code></p>
                <p><strong>Prop√≥sito:</strong> Escanea un directorio de im√°genes, extrae metadatos b√°sicos y coordenadas GPS, y los almacena en MongoDB con geocodificaci√≥n autom√°tica.</p>
                <p><strong>¬øCu√°ndo ejecutar?</strong> Despu√©s de actualizar los IDs y antes de extraer metadatos adicionales.</p>
            </div>

            <div class="step">
                <h3>3. Extracci√≥n de XMP</h3>
                <p>Ubicaci√≥n: <code>3_EXTRAER_XMP/</code></p>
                <p><strong>Prop√≥sito:</strong> Extrae metadatos XMP espec√≠ficos relacionados con personas identificadas en las im√°genes y todos los metadatos XMP/EXIF.</p>
                <p><strong>¬øCu√°ndo ejecutar?</strong> Despu√©s de haber alimentado la base de datos con im√°genes.</p>
                <ul>
                    <li><code>1_extraer_xmp_a_mongodb .py</code> - Extrae nombres de personas desde metadatos XMP</li>
                    <li><code>2_extraer_todos_metadatos_a_mongodb.py</code> - Extrae todos los metadatos XMP y EXIF</li>
                </ul>
            </div>

            <div class="step">
                <h3>4. Generaci√≥n de Estad√≠sticas (Opcional)</h3>
                <p>Ubicaci√≥n: <code>GENERAR_ESTADISTICAS_MONGODB/generar_estadisticas_mongodb.py</code></p>
                <p><strong>Prop√≥sito:</strong> Genera estad√≠sticas matem√°ticas y categ√≥ricas completas sobre todos los datos procesados.</p>
                <p><strong>¬øCu√°ndo ejecutar?</strong> En cualquier momento despu√©s de tener datos en la base de datos.</p>
            </div>
        </section>

        <section id="modulo-1">
            <h2>5. M√≥dulo 1: Actualizaci√≥n de IDs MongoDB</h2>

            <div class="requirements">
                <h3>Dependencias necesarias:</h3>
                <ul>
                    <li>pymongo</li>
                    <li>hashlib (incluido en Python est√°ndar)</li>
                    <li>os (incluido en Python est√°ndar)</li>
                </ul>
            </div>

            <p><strong>Funcionamiento:</strong> Este script se conecta a MongoDB y recorre todos los documentos de la colecci√≥n especificada. Para cada documento que tenga una ruta de archivo accesible, calcula el hash SHA-512 del contenido de la imagen y compara con el _id actual. Si no coinciden, actualiza el documento para usar el hash como _id √∫nico.</p>

            <p><strong>Pasos de ejecuci√≥n:</strong></p>
            <ul>
                <li>Configurar variables de entorno o usar valores por defecto</li>
                <li>Ejecutar el script: <code>python 1_ACTUALIZAR_ID_MONGODB/actualizar_ids_mongodb_imagenes.py</code></li>
                <li>El script actualiza en base de datos autom√°ticamente</li>
                <li>Mostrar mensajes solo para imagenes modificadas</li>
            </ul>

            <h3>C√≥digo fuente:</h3>
            <div class="code"><code>1_ACTUALIZAR_ID_MONGODB/actualizar_ids_mongodb_imagenes.py</code>
<pre>
"""
Actualizar ID de MongoDB para Im√°genes

Este script se conecta a una base de datos MongoDB y actualiza los documentos
en la colecci√≥n especificada, utilizando hashes SHA-512 calculados a partir
de los archivos de imagen para establecer el campo _id y evitar duplicados.

Funcionalidades principales:
- Calcula el hash SHA-512 de archivos de imagen.
- Actualiza documentos en MongoDB si el hash no coincide con el _id actual.
- Maneja casos de duplicados para evitar eliminaci√≥n de datos existentes.
- Imprime mensajes para archivos modificados.

Configuraci√≥n requerida (puede personalizarse con variables de entorno):
- MONGO_URI: URI de conexi√≥n a MongoDB (por defecto: mongodb://localhost:27017).
- DB_NAME: Nombre de la base de datos (por defecto: "your_database_name").
- COLLECTION_NAME: Nombre de la colecci√≥n (por defecto: "your_collection_name").

Notas:
- El campo "ruta" en cada documento debe contener la ruta completa al archivo de imagen.
- Solo procesa documentos donde la ruta existe y es accesible.
- Cierra la conexi√≥n a MongoDB al finalizar.
"""
import os
import hashlib
from pymongo import MongoClient

# --- CONFIGURACI√ìN (Usar variables de entorno para personalizaci√≥n) ---
MONGO_URI = os.environ.get("MONGO_URI", "mongodb://localhost:27017")
DB_NAME = os.environ.get("DB_NAME", "your_database_name")
COLLECTION_NAME = os.environ.get("COLLECTION_NAME", "your_collection_name")

def calcular_sha512(ruta):
    """Calcula el hash SHA-512 de un archivo dado"""
    sha512 = hashlib.sha512()
    with open(ruta, "rb") as f:
        for bloque in iter(lambda: f.read(4096), b""):
            sha512.update(bloque)
    return sha512.hexdigest()

def main():
    # Conexi√≥n a MongoDB
    cliente = MongoClient(MONGO_URI)
    db = cliente[DB_NAME]
    coleccion = db[COLLECTION_NAME]

    # Recorremos documentos
    for doc in coleccion.find({}):
        ruta = doc.get("ruta")
        if not ruta or not os.path.exists(ruta):
            continue

        # Calcular hash actual de la imagen
        hash_actual = calcular_sha512(ruta)

        # Verificar si est√° desactualizado
        if doc["_id"] != hash_actual or doc.get("hash") != hash_actual:
            # Chequear si ya existe un documento con _id = hash_actual
            existing = coleccion.find_one({"_id": hash_actual})
            if not existing:
                # Si no existe, insertar nuevo y eliminar viejo
                nuevo_doc = dict(doc)
                nuevo_doc["_id"] = hash_actual
                nuevo_doc["hash"] = hash_actual
                coleccion.insert_one(nuevo_doc)
                coleccion.delete_one({"_id": doc["_id"]})
                print(f"Archivo modificado: {ruta}")
            else:
                # Si existe, no hacer nada para evitar eliminaci√≥n
                pass
        # Si no necesita actualizaci√≥n, no informa nada

    cliente.close()

if __name__ == "__main__":
    main()
</pre></div>
        </section>

        <section id="modulo-2">
            <h2>6. M√≥dulo 2: Alimentaci√≥n de la Base de Datos</h2>

            <div class="requirements">
                <h3>Dependencias necesarias:</h3>
                <ul>
                    <li>os (incluido en Python est√°ndar)</li>
                    <li>sys (incluido en Python est√°ndar)</li>
                    <li>exifread</li>
                    <li>requests</li>
                    <li>pymongo</li>
                    <li>datetime (incluido en Python est√°ndar)</li>
                    <li>PIL (Pillow)</li>
                    <li>hashlib (incluido en Python est√°ndar)</li>
                </ul>

                <h3>Archivos que afectan:</h3>
                <ul>
                    <li>Requiere edici√≥n del directorio TARGET_DIRECTORY en el script</li>
                </ul>
            </div>

            <p><strong>Funcionamiento:</strong> Este script procesa todas las im√°genes en un directorio espec√≠fico, extrae metadatos b√°sicos como dimensiones, peso, fecha de creaci√≥n, calcula el hash SHA-512 y procesa coordenadas GPS si est√°n disponibles. Realiza geocodificaci√≥n inversa para obtener direcci√≥n completa desde las coordenadas.</p>

            <p><strong>Pasos de configuraci√≥n y ejecuci√≥n:</strong></p>
            <ol>
                <li>Editar el script: Cambiar la variable <code>DIRECTORY</code> por la ruta donde est√°n las im√°genes</li>
                <li>Configurar MongoDB URI si es necesario</li>
                <li>Ejecutar: <code>python 2_ALIMENTAR_BD/1-alimentar.py</code></li>
                <li>El script mostrar√° progreso por cada imagen procesada</li>
            </ol>

            <div class="warning">
                <strong>Nota:</strong> Aseg√∫rese que MongoDB est√© ejecut√°ndose antes de iniciar el procesamiento.
            </div>

            <h3>C√≥digo fuente:</h3>
            <div class="code"><code>2_ALIMENTAR_BD/1-alimentar.py</code>
<pre>
# CONDA: your_environment
"""
Script para alimentar una base de datos MongoDB con metadatos de im√°genes.

Este m√≥dulo procesa im√°genes de un directorio espec√≠fico, extrae metadatos
como dimensiones, fecha de creaci√≥n, coordenadas GPS y direcci√≥n geocodificada,
y los almacena en una colecci√≥n de MongoDB usando el hash SHA512 del archivo
como identificador √∫nico.
"""

import os
import sys
import exifread
import requests
import pymongo
from datetime import datetime
import hashlib
from PIL import Image

# Constante para el directorio a escanear
DIRECTORY = '/path/to/your/image/directory'  # Cambia esta ruta por la deseada
MONGO_URI = "mongodb://localhost:27017"
DB_NAME = "your_database_name"
COLLECTION_NAME = "images_collection"

# Conexi√≥n a MongoDB
client = pymongo.MongoClient(MONGO_URI)
db = client[DB_NAME]
collection = db[COLLECTION_NAME]

def get_file_hash(file_path):
    """
    Calcula el hash SHA512 del archivo para identificar duplicados.

    Args:
        file_path (str): Ruta completa al archivo de imagen.

    Returns:
        str or None: Hash SHA512 en formato hexadecimal, o None si ocurre un error.
    """
    hash_obj = hashlib.sha512()
    try:
        with open(file_path, 'rb') as f:
            while chunk := f.read(8192):
                hash_obj.update(chunk)
        return hash_obj.hexdigest()
    except Exception:
        return None

def get_image_metadata(file_path):
    """
    Extrae metadatos b√°sicos de la imagen usando PIL.

    Args:
        file_path (str): Ruta completa al archivo de imagen.

    Returns:
        dict or None: Diccionario con metadatos de la imagen incluyendo:
            - nombre_archivo: Nombre del archivo
            - ruta_completa: Ruta completa del archivo
            - ancho: Ancho de la imagen en p√≠xeles
            - alto: Alto de la imagen en p√≠xeles
            - fecha_creacion: Timestamp de modificaci√≥n del archivo
            - coordenadas: None (se completa posteriormente con GPS)
            - fecha_procesamiento: Timestamp del momento del procesamiento
            Retorna None si ocurre un error al procesar la imagen.
    """
    try:
        with Image.open(file_path) as img:
            width, height = img.size
            fecha_dt = datetime.fromtimestamp(os.path.getmtime(file_path))
            fecha_proc_dt = datetime.now()
            return {
                'nombre': os.path.basename(file_path),
                'ruta': file_path,
                'ancho': width,
                'alto': height,
                'peso': os.path.getsize(file_path) / 1024,
                'fecha_creacion_dia': fecha_dt.strftime('%d'),
                'fecha_creacion_mes': fecha_dt.strftime('%m'),
                'fecha_creacion_anio': fecha_dt.strftime('%Y'),
                'fecha_creacion_hora': fecha_dt.strftime('%H'),
                'fecha_creacion_minuto': fecha_dt.strftime('%M'),
                'coordenadas': None,
                'fecha_procesamiento_dia': fecha_proc_dt.strftime('%d'),
                'fecha_procesamiento_mes': fecha_proc_dt.strftime('%m'),
                'fecha_procesamiento_anio': fecha_proc_dt.strftime('%Y'),
                'fecha_procesamiento_hora': fecha_proc_dt.strftime('%H'),
                'fecha_procesamiento_minuto': fecha_proc_dt.strftime('%M')
            }
    except Exception as e:
        print(f"Error extrayendo metadatos de {file_path}: {e}")
        return None

def dms_to_decimal(dms, ref):
    """
    Convierte coordenadas del formato DMS (grados, minutos, segundos) a formato decimal.

    Args:
        dms: Tupla con tres valores FRS (Fractional Rational String) representando
             grados, minutos y segundos de las coordenadas GPS.
        ref (str): Referencia de direcci√≥n ('N', 'S', 'E', 'W').

    Returns:
        float: Coordenadas en formato decimal. Negativas para 'S' y 'W'.
    """
    degrees = dms[0].num / dms[0].den
    minutes = dms[1].num / dms[1].den
    seconds = dms[2].num / dms[2].den
    decimal = degrees + (minutes / 60) + (seconds / 3600)
    if ref in ['S', 'W']:
        decimal = -decimal
    return decimal

def reverse_geocode(lat, lon):
    """
    Realiza geocodificaci√≥n inversa usando la API de Nominatim (OpenStreetMap).

    Args:
        lat (float): Latitud en formato decimal.
        lon (float): Longitud en formato decimal.

    Returns:
        dict or None: Diccionario con informaci√≥n de direcci√≥n estructurada, o None si falla.
                     Contiene: display_name, address (con road, suburb, city, postcode, country)
    """
    try:
        url = f"https://nominatim.openstreetmap.org/reverse?format=json&lat={lat}&lon={lon}&zoom=18&addressdetails=1"
        headers = {'User-Agent': 'anonymous_image_processor'}
        response = requests.get(url, headers=headers, timeout=10)

        if response.status_code == 200:
            data = response.json()
            if 'address' in data:
                address_details = data.get('address', {})
                structured_address = {
                    'display_name': data.get('display_name', ''),
                    'address': {
                        'road': address_details.get('road', ''),
                        'suburb': address_details.get('suburb', ''),
                        'city': address_details.get('city', ''),
                        'postcode': address_details.get('postcode', ''),
                        'country': address_details.get('country', '')
                    }
                }
                return structured_address
            else:
                print(f"API response missing address details: {data}")
                return None
        else:
            print(f"Geocoding API error {response.status_code}: {response.text}")
            return None
    except requests.exceptions.RequestException as e:
        print(f"Network error during geocoding: {e}")
        return None

def get_gps_location(file_path):
    """
    Procesa una imagen para extraer informaci√≥n GPS y actualizar la base de datos.

    Calcula el hash del archivo, verifica si ya existe en la base de datos,
    extrae coordenadas GPS de los metadatos EXIF, las geocodifica a componentes de direcci√≥n,
    y actualiza el documento en MongoDB. Si el documento no existe, lo crea primero
    con metadatos b√°sicos.

    Args:
        file_path (str): Ruta completa al archivo de imagen a procesar.

    Returns:
        None: No retorna valores, actualiza la base de datos directamente.

    Raises:
        Exception: Se maneja internamente imprimiendo mensajes de error.
    """
    try:
        hash_value = get_file_hash(file_path)
        if not hash_value:
            print(f"Error calculando hash para {file_path}")
            return

        # Comprobar si la imagen ya existe en la base de datos por hash
        document = collection.find_one({'_id': hash_value})
        if document:
            print(f"Imagen ya existe en la base de datos, saltando procesamiento: {file_path}")
            return

        # Si no existe, insertar nuevo documento
        metadata = get_image_metadata(file_path)
        if metadata:
            metadata['_id'] = hash_value
            metadata['hash_sha512'] = hash_value
            try:
                collection.insert_one(metadata)
                print(f"Documento insertado: {file_path}")
            except Exception as e:
                print(f"Error insertando documento: {e}")
                return
        else:
            print(f"No se pudo obtener metadatos para insertar: {file_path}")
            return

        with open(file_path, 'rb') as f:
            tags = exifread.process_file(f, details=False)

        update_data = {}

        # Inicializar siempre coordenadas y componentes de direcci√≥n
        coordenadas = None
        calle = ''
        barrio = ''
        ciudad = ''
        cp = ''
        pais = ''

        if 'GPS GPSLatitude' in tags and 'GPS GPSLongitude' in tags:
            lat_tag = tags['GPS GPSLatitude']
            lon_tag = tags['GPS GPSLongitude']
            lat_ref = str(tags['GPS GPSLatitudeRef'])
            lon_ref = str(tags['GPS GPSLongitudeRef'])
            lat = dms_to_decimal(lat_tag.values, lat_ref)
            lon = dms_to_decimal(lon_tag.values, lon_ref)
            coordenadas = [lat, lon]

            address_data = reverse_geocode(lat, lon)
            if address_data:
                # Guardar componentes de direcci√≥n por separado
                address_details = address_data.get('address', {})
                calle = address_details.get('road', '')
                barrio = address_details.get('suburb', '')
                ciudad = address_details.get('city', '')
                cp = address_details.get('postcode', '')
                pais = address_details.get('country', '')
                print(f"Direcci√≥n geocodificada: {address_data.get('display_name', '')}")
            else:
                print(f"No se pudo geocodificar: coordenadas {lat}, {lon}")

            print(f"Actualizado {file_path} con GPS")
        else:
            print(f"Sin GPS: {file_path}")

        # Siempre insertar los datos GPS y de direcci√≥n
        update_data['coordenadas'] = coordenadas
        update_data['calle'] = calle
        update_data['barrio'] = barrio
        update_data['ciudad'] = ciudad
        update_data['cp'] = cp
        update_data['pais'] = pais

        # Siempre actualizar fecha_procesamiento con campos separados
        now = datetime.now()
        update_data['fecha_procesamiento_dia'] = now.strftime('%d')
        update_data['fecha_procesamiento_mes'] = now.strftime('%m')
        update_data['fecha_procesamiento_anio'] = now.strftime('%Y')
        update_data['fecha_procesamiento_hora'] = now.strftime('%H')
        update_data['fecha_procesamiento_minuto'] = now.strftime('%M')

        collection.update_one({'_id': hash_value}, {'$set': update_data})

    except Exception as e:
        print(f"Error procesando {file_path}: {e}")

def main():
    """
    Funci√≥n principal que escanea el directorio definido y procesa todas las im√°genes.

    Escanea recursivamente el directorio DIRECTORY en busca de archivos de imagen
    con extensiones v√°lidas (jpg, jpeg, png, tiff, bmp), y para cada imagen encontrada
    ejecuta el procesamiento completo: extracci√≥n de metadatos, GPS y actualizaci√≥n
    en la base de datos MongoDB.

    Returns:
        None: No retorna valores, imprime informaci√≥n de progreso en consola.

    Raises:
        SystemExit: Si el directorio especificado en DIRECTORY no existe.
    """
    dir_path = DIRECTORY
    if not os.path.isdir(dir_path):
        print("El directorio no existe.")
        sys.exit(1)

    print(f"Procesando directorio: {dir_path}\n")

    for root, dirs, files in os.walk(dir_path):
        for file in files:
            ext = file.lower().split('.')[-1]
            if ext in ['jpg', 'jpeg', 'png', 'webp', 'heic', 'heif']:
                path = os.path.join(root, file)
                print(f"Procesando: {path}")
                get_gps_location(path)

if __name__ == "__main__":
    main()
</pre></div>
        </section>

        <section id="modulo-3">
            <h2>7. M√≥dulo 3: Extracci√≥n de XMP</h2>

            <div class="requirements">
                <h3>Dependencias necesarias:</h3>
                <ul>
                    <li>pymongo</li>
                    <li>pyexiv2</li>
                    <li>os (incluido en Python)</li>
                    <li>json (incluido en Python)</li>
                    <li>time (incluido en Python)</li>
                </ul>
            </div>

            <p>Este m√≥dulo tiene dos sub-scripts que procesan metadatos XMP:</p>

            <h3>3.1. Extracci√≥n de Nombres de Personas</h3>
            <p>Extrae nombres de personas identificadas en las fotos desde metadatos XMP y los agrega al campo 'personas' de los documentos en MongoDB.</p>

            <p><strong>Ejecuci√≥n:</strong> <code>python 3_EXTRAER_XMP/1_extraer_xmp_a_mongodb .py</code></p>

            <h4>C√≥digo fuente:</h4>
            <div class="code"><code>3_EXTRAER_XMP/1_extraer_xmp_a_mongodb .py</code>
<pre>
#!/usr/bin/env python3
"""
Script para extraer metadatos XMP espec√≠ficos de im√°genes almacenadas en MongoDB.
Extrae el valor correspondiente a la etiqueta ETIQUETA_XMP de todas las im√°genes
en la colecci√≥n target_collection de la base de datos your_database_name.
"""

import os
import json
import time
from pymongo import MongoClient
import pyexiv2

# Constante para la etiqueta XMP base a extraer
ETIQUETA_XMP_BASE = "Xmp.mwg-rs.Regions/mwg-rs:RegionList"

def conectar_mongodb(host='localhost', port=27017, db_name='your_database_name'):
    """Conecta a la base de datos MongoDB"""
    try:
        client = MongoClient(host, port)
        db = client[db_name]
        print(f"[‚úî] Conectado exitosamente a MongoDB: {db_name}")
        return db
    except Exception as e:
        print(f"[‚úò] Error conectando a MongoDB: {e}")
        return None

def obtener_rutas_imagenes(db):
    """Obtiene todas las rutas de im√°genes de la colecci√≥n target_collection"""
    try:
        collection = db['target_collection']
        cursor = collection.find({}, {'ruta': 1, '_id': 0})
        rutas = [doc['ruta'] for doc in cursor if 'ruta' in doc]
        print(f"[‚úî] Encontradas {len(rutas)} rutas de im√°genes en la base de datos")
        return rutas
    except Exception as e:
        print(f"[‚úò] Error obteniendo rutas de im√°genes: {e}")
        return []

def limpiar_valor_xmp(valor_completo):
    """Limpia el valor XMP para extraer solo el nombre limpio"""
    try:
        # El formato t√≠pico es: "<Xmp.mwg-rs.Regions/mwg-rs:RegionList[1]/mwg-rs:Name [Text] = Abuela Aurora>"
        # Necesitamos extraer todo lo que viene despu√©s del "="
        if "=" in valor_completo:
            partes = valor_completo.split("=", 1)
            if len(partes) == 2:
                valor = partes[1].strip()

                # Limpiar comillas y caracteres de cierre
                valor = valor.rstrip('>').strip()
                if valor.startswith('"') and valor.endswith('"'):
                    valor = valor[1:-1]
                elif valor.startswith("'") and valor.endswith("'"):
                    valor = valor[1:-1]

                return valor.strip()
        return None
    except Exception as e:
        print(f"[!] Error limpiando valor XMP: {e}")
        return None

def extraer_valores_etiquetas_xmp(imagen_path, etiqueta_base):
    """Extrae m√∫ltiples valores de etiquetas XMP de una imagen"""
    try:
        # Verificar si el archivo existe
        if not os.path.exists(imagen_path):
            print(f"[‚úò] Archivo no encontrado: {imagen_path}")
            return []

        print(f"[...] Procesando: {imagen_path}")

        # Leer metadatos usando pyexiv2
        metadata = pyexiv2.ImageMetadata(imagen_path)
        metadata.read()

        valores_encontrados = []
        indice = 1

        # Buscar todas las etiquetas numeradas
        while True:
            etiqueta_actual = etiqueta_base + f"[{indice}]/mwg-rs:Name"
            if etiqueta_actual in metadata:
                valor_completo = metadata[etiqueta_actual]
                print(f"[‚úî] Valor encontrado en {etiqueta_actual}: {valor_completo}")

                # Limpiar el valor extra√≠do para obtener solo el nombre
                valor_limpio = limpiar_valor_xmp(str(valor_completo))
                if valor_limpio:
                    print(f"[‚úî] Valor limpio extra√≠do: {valor_limpio}")
                    if valor_limpio not in valores_encontrados:  # Evitar duplicados internos
                        valores_encontrados.append(valor_limpio)
            else:
                break  # No hay m√°s etiquetas numeradas

            indice += 1

        if not valores_encontrados:
            print(f"[!] Ninguna etiqueta XMP encontrada en {imagen_path}")

        return valores_encontrados

    except Exception as e:
        print(f"[‚úò] Error procesando {imagen_path}: {e}")
        return []

def main():
    """Funci√≥n principal"""
    print("=== Extractor de XMP desde MongoDB ===")
    print(f"Etiqueta XMP base a extraer: {ETIQUETA_XMP_BASE}")
    print("=" * 50)

    # Conectar a MongoDB
    db = conectar_mongodb()
    if db is None:
        return

    # Obtener colecci√≥n y rutas de im√°genes
    collection = db['target_collection']
    rutas_imagenes = obtener_rutas_imagenes(db)
    if not rutas_imagenes:
        print("No se encontraron rutas de im√°genes en la base de datos")
        return

    print(f"Procesando {len(rutas_imagenes)} im√°genes...")
    print("-" * 50)

    # Contadores
    imagenes_procesadas = 0
    imagenes_con_valor = 0
    documentos_actualizados = 0
    valores_agregados = 0

    # Procesar cada imagen
    for ruta in rutas_imagenes:
        print(f"\nProcesando imagen {imagenes_procesadas + 1}/{len(rutas_imagenes)}:")

        # Extraer m√∫ltiples valores XMP
        valores_etiqueta = extraer_valores_etiquetas_xmp(ruta, ETIQUETA_XMP_BASE)

        if valores_etiqueta:
            imagenes_con_valor += 1

            # Mostrar los valores encontrados
            print("=" * 50)
            print(f"RUTA: {ruta}")
            print(f"VALORES ENCONTRADOS ({len(valores_etiqueta)}): {', '.join(valores_etiqueta)}")
            print("=" * 50)

            # Actualizar el documento en MongoDB siguiendo el flujo exacto solicitado
            try:
                # PASO 1: Primero, verificar y preparar el campo 'personas'
                doc = collection.find_one({"ruta": ruta})
                if doc:
                    # PASO 2: Verificar si campo 'personas' existe, sino crearlo vac√≠o
                    if 'personas' not in doc or doc['personas'] is None:
                        lista_personas_actual = []
                        print(f"[i] Campo 'personas' no existe, inicializado vac√≠o")
                    else:
                        if isinstance(doc['personas'], list):
                            lista_personas_actual = doc['personas'].copy()
                            print(f"[i] Campo 'personas' existe con {len(lista_personas_actual)} valores: {lista_personas_actual}")
                        else:
                            # Si no es lista, crear nueva lista vac√≠a
                            lista_personas_actual = []
                            print(f"[i] Campo 'personas' existe pero no es lista, inicializado vac√≠o")

                    # PASO 3: Procesar la imagen y extraer metadatos a otra lista
                    lista_valores_extraidos = valores_etiqueta.copy()
                    print(f"[i] Valores extra√≠dos de XMP: {lista_valores_extraidos}")

                    # PASO 4: Comparar ambas listas y a√±adir solo valores nuevos
                    valores_a_anadir = []
                    for valor_extraido in lista_valores_extraidos:
                        if valor_extraido not in lista_personas_actual:
                            lista_personas_actual.append(valor_extraido)
                            valores_a_anadir.append(valor_extraido)

                    # PASO 5: Actualizar el campo personas solo si hay cambios
                    if valores_a_anadir:
                        print(f"[‚úî] A√±adiendo valores nuevos: {valores_a_anadir}")
                        print(f"[‚úî] Campo 'personas' actualizado a: {lista_personas_actual}")

                        result = collection.update_one(
                            {"ruta": ruta},
                            {"$set": {"personas": lista_personas_actual}}
                        )

                        if result.modified_count > 0:
                            documentos_actualizados += 1
                            valores_agregados += len(valores_a_anadir)
                            print(f"[‚úî] Documento actualizado correctamente")
                        else:
                            print(f"[!] Error: No se pudo actualizar el documento")
                    else:
                        print(f"[i] No hay valores nuevos que a√±adir")
                        # Aun asi contamos la imagen como procesada

                else:
                    print(f"[!] Documento no encontrado para ruta: {ruta}")

            except Exception as e:
                print(f"[‚úò] Error actualizando documento para {ruta}: {e}")

        else:
            print(f"[!] No se encontraron valores para etiquetas XMP en: {ruta}")

        imagenes_procesadas += 1

    # Resumen final
    print("\n" + "=" * 60)
    print("=== RESUMEN DEL PROCESAMIENTO ===")
    print("=" * 60)
    print(f"Total de im√°genes procesadas: {imagenes_procesadas}")
    print(f"Im√°genes con valores en etiquetas: {imagenes_con_valor}")
    print(f"Im√°genes sin valores en etiquetas: {imagenes_procesadas - imagenes_con_valor}")
    print(f"Documentos actualizados: {documentos_actualizados}")
    print(f"Valores agregados al campo 'personas': {valores_agregados}")

    print("\n" + "Procesamiento completado. Los documentos en MongoDB han sido actualizados con el campo 'personas'.")

if __name__ == "__main__":
    # Verificar dependencias
    try:
        import pymongo
        import pyexiv2
    except ImportError as e:
        print(f"[‚úò] Falta dependencia - {e}")
        print("Instala las dependencias con:")
        print("pip install pymongo pyexiv2")
        exit(1)

    main()
</pre></div>

            <h3>3.2. Extracci√≥n Completa de Metadatos</h3>
            <p>Extrae todos los metadatos XMP y EXIF y los guarda en una colecci√≥n separada.</p>

            <p><strong>Ejecuci√≥n:</strong> <code>python 3_EXTRAER_XMP/2_extraer_todos_metadatos_a_mongodb.py</code></p>

            <h4>C√≥digo fuente:</h4>
            <div class="code"><code>3_EXTRAER_XMP/2_extraer_todos_metadatos_a_mongodb.py</code>
<pre>
#!/usr/bin/env python3
"""
Script para extraer TODOS los metadatos XMP y EXIF de im√°genes almacenadas en MongoDB.
Extrae todos los metadatos XMP y EXIF de todas las im√°genes en la colecci√≥n target_collection
de la base de datos your_database_name y los guarda en la colecci√≥n target_metadata_collection.
"""

import os
import time
from pymongo import MongoClient
import pyexiv2

def conectar_mongodb(host='localhost', port=27017, db_name='your_database_name'):
    """Conecta a la base de datos MongoDB"""
    try:
        client = MongoClient(host, port)
        db = client[db_name]
        print(f"[‚úî] Conectado exitosamente a MongoDB: {db_name}")
        return db
    except Exception as e:
        print(f"[‚úò] Error conectando a MongoDB: {e}")
        return None

def obtener_rutas_imagenes(db):
    """Obtiene todas las rutas de im√°genes de la colecci√≥n target_collection"""
    try:
        collection = db['target_collection']
        cursor = collection.find({}, {'ruta': 1, '_id': 0})
        rutas = [doc['ruta'] for doc in cursor if 'ruta' in doc]
        print(f"[‚úî] Encontradas {len(rutas)} rutas de im√°genes en la base de datos")
        return rutas
    except Exception as e:
        print(f"[‚úò] Error obteniendo rutas de im√°genes: {e}")
        return []

def extraer_todos_metadatos(imagen_path):
    """Extrae todos los metadatos XMP y EXIF de una imagen"""
    try:
        # Verificar si el archivo existe
        if not os.path.exists(imagen_path):
            print(f"[‚úò] Archivo no encontrado: {imagen_path}")
            return {}

        print(f"[...] Procesando: {imagen_path}")

        # Leer metadatos usando pyexiv2
        metadata = pyexiv2.ImageMetadata(imagen_path)
        metadata.read()

        # Diccionario para almacenar todos los metadatos
        all_metadata = {}

        # Iterar sobre todos los metadatos disponibles
        for key in metadata:
            if key.startswith(('Xmp.', 'Exif.')):  # Extraer metadatos XMP y EXIF
                try:
                    valor = metadata[key]
                    # Convertir valor a string o mantener tipo original si es simple
                    if isinstance(valor, (int, float, str)):
                        valor_limpio = valor
                    else:
                        valor_limpio = str(valor)
                    all_metadata[key] = valor_limpio
                    print(f"[‚úî] Metadato encontrado: {key} = {valor_limpio}")
                except Exception as e:
                    print(f"[!] Error extrayendo {key}: {e}")
                    all_metadata[key] = f"Error: {str(e)}"

        if not all_metadata:
            print(f"[!] No se encontraron metadatos XMP o EXIF en {imagen_path}")

        return all_metadata

    except Exception as e:
        print(f"[‚úò] Error procesando {imagen_path}: {e}")
        return {}

def main():
    """Funci√≥n principal"""
    print("=== Extractor de TODOS los metadatos XMP y EXIF desde MongoDB ===")
    print("Guardar en colecci√≥n: target_metadata_collection")
    print("=" * 60)

    # Conectar a MongoDB
    db = conectar_mongodb()
    if db is None:
        return

    # Obtener colecci√≥n fuente y rutas de im√°genes
    collection_fuente = db['target_collection']
    rutas_imagenes = obtener_rutas_imagenes(db)
    if not rutas_imagenes:
        print("No se encontraron rutas de im√°genes en la base de datos")
        return

    # Nueva colecci√≥n para guardar todos los metadatos
    collection_metadatos = db['target_metadata_collection']

    print(f"Procesando {len(rutas_imagenes)} im√°genes...")
    print("-" * 50)

    # Contadores
    imagenes_procesadas = 0
    imagenes_con_metadatos = 0
    documentos_insertados = 0

    # Procesar cada imagen
    for ruta in rutas_imagenes:
        print(f"\nProcesando imagen {imagenes_procesadas + 1}/{len(rutas_imagenes)}:")

        # Extraer todos los metadatos
        all_metadata = extraer_todos_metadatos(ruta)

        if all_metadata:
            imagenes_con_metadatos += 1

            # Mostrar los metadatos encontrados (resumido)
            print("=" * 60)
            print(f"RUTA: {ruta}")
            print(f"METADATOS ENCONTRADOS ({len(all_metadata)}):")
            for key, value in all_metadata.items():
                print(f"  {key}: {value}")
            print("=" * 60)

            # Verificar si ya existe un documento para esta imagen
            documento_existente = collection_metadatos.find_one({"ruta_imagen": ruta})

            # Preparar documento con metadatos como campos individuales
            documento_metadatos = {
                "ruta_imagen": ruta,
                "fecha_extraccion": time.strftime("%Y-%m-%d %H:%M:%S")
            }
            documento_metadatos.update(all_metadata)  # Agregar todos los metadatos como campos individuales

            if documento_existente:
                # Comparar los metadatos uno por uno para ver si han cambiado
                campos_han_cambiado = False

                # Crear diccionario con solo los cambios
                campos_actualizar = {
                    "fecha_extraccion": time.strftime("%Y-%m-%d %H:%M:%S")
                }

                for key, new_value in all_metadata.items():
                    existing_value = documento_existente.get(key)
                    if existing_value != new_value:
                        campos_han_cambiado = True
                        campos_actualizar[key] = new_value
                        print(f"[‚úî] Campo {key} cambiado de '{existing_value}' a '{new_value}'")

                if campos_han_cambiado:
                    print(f"[‚úî] Actualizando campos modificados para {ruta}")

                    # Actualizar el documento existente
                    try:
                        result = collection_metadatos.update_one(
                            {"ruta_imagen": ruta},
                            {"$set": campos_actualizar}
                        )

                        if result.modified_count > 0:
                            documentos_insertados += 1
                            print(f"[‚úî] Documento actualizado en target_metadata_collection")
                        else:
                            print(f"[!] Error: No se pudo actualizar el documento")
                    except Exception as e:
                        print(f"[‚úò] Error actualizando documento para {ruta}: {e}")
                else:
                    print(f"[i] Ning√∫n campo ha cambiado para {ruta}, saltando actualizaci√≥n")
            else:
                # Insertar nuevo documento
                try:
                    result = collection_metadatos.insert_one(documento_metadatos)
                    if result.inserted_id:
                        documentos_insertados += 1
                        print(f"[‚úî] Documento insertado en target_metadata_collection con ID: {result.inserted_id}")
                    else:
                        print(f"[!] Error: No se pudo insertar el documento")
                except Exception as e:
                    print(f"[‚úò] Error insertando documento para {ruta}: {e}")

        else:
            print(f"[!] No se encontraron metadatos en: {ruta}")

        imagenes_procesadas += 1

    # Resumen final
    print("\n" + "=" * 60)
    print("=== RESUMEN DEL PROCESAMIENTO ===")
    print("=" * 60)
    print(f"Total de im√°genes procesadas: {imagenes_procesadas}")
    print(f"Im√°genes con metadatos: {imagenes_con_metadatos}")
    print(f"Im√°genes sin metadatos: {imagenes_procesadas - imagenes_con_metadatos}")
    print(f"Documentos insertados en target_metadata_collection: {documentos_insertados}")

    print("\n" + "Procesamiento completado. Metadatos salvados en colecci√≥n 'target_metadata_collection'.")

if __name__ == "__main__":
    # Verificar dependencias
    try:
        import pymongo
        import pyexiv2
    except ImportError as e:
        print(f"[‚úò] Falta dependencia - {e}")
        print("Instala las dependencias con:")
        print("pip install pymongo pyexiv2")
        exit(1)

    main()
</pre></div>
        </section>

        <section id="modulo-4">
            <h2>8. M√≥dulo 4: Generaci√≥n de Estad√≠sticas</h2>

            <div class="requirements">
                <h3>Dependencias necesarias:</h3>
                <ul>
                    <li>pymongo</li>
                    <li>pandas</li>
                    <li>colorama (opcional)</li>
                    <li>collections (incluido en Python)</li>
                    <li>datetime (incluido en Python)</li>
                    <li>statistics (incluido en Python)</li>
                    <li>os (incluido en Python)</li>
                </ul>

                <h3>Dependencias opcionales:</h3>
                <ul>
                    <li>colorama para salida coloreada</li>
                </ul>
            </div>

            <p><strong>Funcionamiento:</strong> Este script genera estad√≠sticas completas sobre todos los datos almacenados en la colecci√≥n MongoDB especificada. Calcula estad√≠sticas matem√°ticas, frecuencias de valores, letras medias y m√°s.</p>

            <p><strong>Caracter√≠sticas:</strong></p>
            <ul>
                <li>Estad√≠sticas sobre nombres de archivos (extensiones, longitudes)</li>
                <li>Estad√≠sticas num√©ricas sobre dimensiones y pesos</li>
                <li>An√°lisis temporal de fechas de creaci√≥n y procesamiento</li>
                <li>Estad√≠sticas geogr√°ficas por barrio, ciudad, pa√≠s</li>
                <li>An√°lisis de arrays de objetos y personas detectadas</li>
                <li>Salida coloreada (si colorama est√° disponible)</li>
                <li>Guardado autom√°tico de resultados en archivo .dat con timestamp</li>
            </ul>

            <p><strong>Ejecuci√≥n:</strong> <code>python GENERAR_ESTADISTICAS_MONGODB/generar_estadisticas_mongodb.py</code></p>

            <p><strong>Variables de entorno:</strong></p>
            <ul>
                <li><code>MONGODB_URI</code> - URI de MongoDB (por defecto: mongodb://localhost:27017/)</li>
                <li><code>DATABASE_NAME</code> - Nombre de la base de datos (por defecto: album)</li>
                <li><code>COLLECTION_NAME</code> - Nombre de la colecci√≥n (por defecto: imagenes_2)</li>
            </ul>

            <h4>C√≥digo fuente:</h4>
            <div class="code"><code>GENERAR_ESTADISTICAS_MONGODB/generar_estadisticas_mongodb.py</code>
<pre>
"""
Generador de Estad√≠sticas Completas para Colecci√≥n MongoDB

Este m√≥dulo genera estad√≠sticas matem√°ticas y categ√≥ricas completas a partir de una colecci√≥n
MongoDB espec√≠fica. Se conecta a una instancia de MongoDB (local o remota), recupera datos de la colecci√≥n
especificada, procesa los datos en un DataFrame de pandas, calcula estad√≠sticas detalladas
sobre nombres de archivos, dimensiones de im√°genes, fechas, ubicaciones, objetos detectados
y otros campos, muestra los resultados en formato legible con colores (opcionalmente),
y guarda los resultados en un archivo .dat con marca de tiempo.

Dependencias principales:
- pymongo: Para interacci√≥n con MongoDB
- pandas: Para manipulaci√≥n de datos
- colorama: Opcional, para salida coloreada en terminal (instalar con: pip install colorama)

Uso:
    Ejecutar directamente: python generar_estadisticas_mongodb.py
    Aseg√∫rate de configurar las variables de entorno MONGODB_URI, DATABASE_NAME y COLLECTION_NAME

Funciones principales:
- connect_to_mongodb(): Establece conexi√≥n con MongoDB
- get_data(): Obtiene todos los documentos de la colecci√≥n
- convert_to_dataframe(): Convierte datos MongoDB a DataFrame con procesamiento de fechas
- compute_statistics(): Calcula estad√≠sticas exhaustivas sobre los datos
- print_statistics(): Imprime estad√≠sticas estructuradas y coloreadas
- save_to_dat_file(): Guarda estad√≠sticas en archivo .dat con timestamp
- main(): Funci√≥n principal que coordina todo el flujo
"""

import pymongo
from pymongo import MongoClient
import pandas as pd
from collections import Counter
from datetime import datetime
import statistics
import sys
import os
try:
    import colorama
    from colorama import Fore, Style, init
    colorama_available = True
except ImportError:
    print("colorama no instalado. Instala con: pip install colorama")
    colorama_available = False

def connect_to_mongodb():
    """
    Conecta a la base de datos MongoDB.
    Usa variables de entorno para configuraci√≥n: MONGODB_URI, DATABASE_NAME, COLLECTION_NAME.
    Si no existen, usa valores por defecto √∫tiles para desarrollo.
    """
    try:
        mongodb_uri = os.getenv('MONGODB_URI', 'mongodb://localhost:27017/')
        database_name = os.getenv('DATABASE_NAME', 'album')
        collection_name = os.getenv('COLLECTION_NAME', 'imagenes_2')

        client = MongoClient(mongodb_uri)
        db = client[database_name]
        collection = db[collection_name]
        print(f"Conectado a MongoDB en {mongodb_uri}, base de datos: {database_name}, colecci√≥n: {collection_name}")
        return collection
    except Exception as e:
        print(f"Error conectando a MongoDB: {e}")
        sys.exit(1)

def get_data(collection):
    """
    Obtiene todos los documentos de la colecci√≥n.
    """
    try:
        data = list(collection.find())
        return data
    except Exception as e:
        print(f"Error obteniendo datos: {e}")
        return []

def convert_to_dataframe(data):
    """
    Convierte la lista de documentos a un DataFrame de pandas.
    """
    if not data:
        print("No data found in collection.")
        return pd.DataFrame()

    df = pd.DataFrame(data)

    # Convertir fechas a objetos datetime
    df['fecha_creacion'] = pd.to_datetime(df['fecha_creacion_anio'].astype(str) + '-' +
                                          df['fecha_creacion_mes'].astype(str) + '-' +
                                          df['fecha_creacion_dia'].astype(str) + ' ' +
                                          df['fecha_creacion_hora'].astype(str) + ':' +
                                          df['fecha_creacion_minuto'].astype(str), errors='coerce')

    df['fecha_procesamiento'] = pd.to_datetime(df['fecha_procesamiento_anio'].astype(str) + '-' +
                                               df['fecha_procesamiento_mes'].astype(str) + '-' +
                                               df['fecha_procesamiento_dia'].astype(str) + ' ' +
                                               df['fecha_procesamiento_hora'].astype(str) + ':' +
                                               df['fecha_procesamiento_minuto'].astype(str), errors='coerce')

    return df

def compute_statistics(df):
    """
    Calcula estad√≠sticas matem√°ticas completas basadas en los datos.
    """
    if df.empty:
        return {}

    stats = {}
    stats['total_registros'] = len(df)

    # Estad√≠sticas sobre nombre (filenames)
    if 'nombre' in df.columns:
        names_filtered = df['nombre'][(df['nombre'].notna()) & (df['nombre'] != "")]
        stats['nombre_total_cantidad'] = len(names_filtered)
        stats['nombre_cantidad_unica'] = names_filtered.nunique()
        stats['nombre_null_cantidad'] = df['nombre'].isnull().sum()
        stats['nombre_vacio_cantidad'] = (df['nombre'] == "").sum()
        if not names_filtered.empty:
            most_common_name = names_filtered.value_counts().idxmax()
            stats['nombre_mas_comun'] = most_common_name
            stats['nombre_mas_comun_cantidad'] = names_filtered.value_counts().iloc[0]
            # Estad√≠sticas sobre extensiones
            extensions = names_filtered.str.extract(r'(\.\w+)$').fillna('')
            extension_counts = extensions[extensions != ""].squeeze().value_counts()
            ext_most_common = extension_counts.idxmax() if not extension_counts.empty else None
            stats['nombre_extension_mas_comun'] = ext_most_common
            stats['nombre_extension_cantidad_unica'] = extension_counts.nunique()
            # Longitud de nombres
            name_lengths = names_filtered.str.len()
            stats['nombre_longitud_media'] = name_lengths.mean()
            stats['nombre_longitud_min'] = name_lengths.min()
            stats['nombre_longitud_max'] = name_lengths.max()
        else:
            stats['nombre_mas_comun'] = None
            stats['nombre_mas_comun_cantidad'] = 0
            stats['nombre_extension_mas_comun'] = None
            stats['nombre_extension_cantidad_unica'] = 0
            stats['nombre_longitud_media'] = None
            stats['nombre_longitud_min'] = None
            stats['nombre_longitud_max'] = None

    # Estad√≠sticas num√©ricas b√°sicas
    numerical_fields = ['ancho', 'alto', 'peso']
    for field in numerical_fields:
        if field in df.columns:
            values = df[field].dropna()
            if not values.empty:
                stats[f'{field}_cantidad'] = len(values)
                stats[f'{field}_media'] = values.mean()
                stats[f'{field}_mediana'] = values.median()
                stats[f'{field}_desviacion_estandar'] = values.std()
                stats[f'{field}_min'] = values.min()
                stats[f'{field}_max'] = values.max()
                stats[f'{field}_q25'] = values.quantile(0.25)
                stats[f'{field}_q75'] = values.quantile(0.75)

    # Estad√≠sticas de fechas
    for date_field in ['fecha_creacion', 'fecha_procesamiento']:
        if date_field in df.columns:
            dates = df[date_field].dropna()
            if not dates.empty:
                stats[f'{date_field}_mas_temprano'] = dates.min()
                stats[f'{date_field}_mas_tarde'] = dates.max()
                stats[f'{date_field}_ano_mas_comun'] = dates.dt.year.value_counts().idxmax()
                stats[f'{date_field}_mes_mas_comun'] = dates.dt.month.value_counts().idxmax()
                stats[f'{date_field}_fecha_media'] = pd.to_datetime(dates).mean()

    # Estad√≠sticas cat√©goricas (ubicaci√≥n)
    location_fields = ['barrio', 'calle', 'ciudad', 'cp', 'pais']
    for field in location_fields:
        if field in df.columns:
            values = df[field]
            filtered_values = values[(values.notna()) & (values != "")]
            stats[f'{field}_cantidad_unica'] = len(filtered_values)
            stats[f'{field}_null_cantidad'] = df[field].isnull().sum() + (df[field] == "").sum()
            if not filtered_values.empty:
                most_common = filtered_values.value_counts().idxmax()
                stats[f'{field}_mas_comun'] = most_common if most_common != "" else None
            else:
                stats[f'{field}_mas_comun'] = None
            stats[f'{field}_vacio_cantidad'] = (df[field] == "").sum()

    # objeto_procesado
    if 'objeto_procesado' in df.columns:
        processed_counts = df['objeto_procesado'].value_counts()
        stats['objeto_procesado_verdadero_cantidad'] = processed_counts.get(True, 0)
        stats['objeto_procesado_falso_cantidad'] = processed_counts.get(False, 0)

    # Estad√≠sticas de arrays
    # objetos
    if 'objetos' in df.columns:
        all_objetos = [obj for sublist in df['objetos'].dropna() for obj in sublist]  # Aplanar lista
        objeto_counts = Counter(all_objetos)
        stats['objetos_total_unico'] = len(objeto_counts)
        stats['objetos_total_cantidad'] = sum(objeto_counts.values())
        stats['objetos_mas_comun'] = objeto_counts.most_common(1)[0] if objeto_counts else None
        # Estad√≠sticas sobre longitudes de array
        array_lengths = df['objetos'].dropna().apply(len)
        stats['objetos_array_longitud_media'] = array_lengths.mean()
        stats['objetos_array_longitud_min'] = array_lengths.min()
        stats['objetos_array_longitud_max'] = array_lengths.max()

    # personas
    if 'personas' in df.columns:
        all_personas = [persona for sublist in df['personas'].dropna() for persona in sublist]
        persona_counts = Counter(all_personas)
        stats['personas_total_unico'] = len(persona_counts)
        stats['personas_total_cantidad'] = sum(persona_counts.values())
        stats['personas_mas_comun'] = persona_counts.most_common(1)[0] if persona_counts else None
        array_lengths = df['personas'].dropna().apply(len)
        stats['personas_array_longitud_media'] = array_lengths.mean() if not array_lengths.empty else 0
        stats['personas_array_longitud_min'] = array_lengths.min() if not array_lengths.empty else 0
        stats['personas_array_longitud_max'] = array_lengths.max() if not array_lengths.empty else 0

    # ruta_alternativa
    if 'ruta_alternativa' in df.columns:
        values = df['ruta_alternativa'].dropna()
        stats['ruta_alternativa_cantidad_unica'] = values.nunique()
        stats['ruta_alternativa_null_cantidad'] = df['ruta_alternativa'].isnull().sum()
        ruta_most_common = values.value_counts().idxmax() if not values.empty else None
        if ruta_most_common == "":
            ruta_most_common = None
        stats['ruta_alternativa_mas_comun'] = ruta_most_common

    # coordenadas
    if 'coordenadas' in df.columns:
        coords = df['coordenadas'].dropna()
        stats['coordenadas_no_null_cantidad'] = len(coords)
        stats['coordenadas_null_cantidad'] = df['coordenadas'].isnull().sum()
        # Asumiendo que son tipo dict o array [lat, lon], pero como en ejemplo es null, dejarlo as√≠

    return stats

def print_statistics(stats, collection_name):
    """
    Imprime las estad√≠sticas de forma legible con colores y estructura.
    """
    if colorama_available:
        init(autoreset=True)

    def print_colored(text, fore_color=None, style=None):
        if not colorama_available:
            print(text)
        else:
            output = ""
            if style:
                output += style
            if fore_color:
                output += fore_color
            print(f"{output}{text}")

    def print_group(title, keys):
        print_colored(f"\n{title}:", Fore.CYAN, Style.BRIGHT)
        for key in keys:
            if key in stats:
                print_colored(f"  {key}: {stats[key]}", Fore.WHITE, Style.NORMAL)

    print_colored(f"Estad√≠sticas Matem√°ticas Completas de la Colecci√≥n '{collection_name}'", Fore.GREEN, Style.BRIGHT)
    print_colored("=" * 80, Fore.YELLOW)

    # Grupos de estad√≠sticas
    general = ['total_registros']
    nombre_stats = [k for k in stats if k.startswith('nombre_')]
    numericas = [k for k in stats if any(k.startswith(f'{f}_') for f in ['ancho', 'alto', 'peso'])]
    fechas = [k for k in stats if '_fecha' in k or 'ano' in k or 'mes' in k or k.endswith('_temprano') or k.endswith('_tarde')]
    ubicacion = [k for k in stats if any(k.startswith(f'{f}_') for f in ['barrio', 'calle', 'ciudad', 'cp', 'pais'])]
    processed = [k for k in stats if 'objeto_procesado' in k]
    arrays = [k for k in stats if 'objetos_' in k or 'personas_' in k]
    other = ['ruta_alternativa_cantidad_unica', 'ruta_alternativa_null_cantidad', 'ruta_alternativa_mas_comun', 'coordenadas_no_null_cantidad', 'coordenadas_null_cantidad']

    print_group("Estad√≠sticas Generales", general)
    print_group("Estad√≠sticas del Nombre", nombre_stats)
    print_group("Estad√≠sticas Num√©ricas", numericas)
    print_group("Estad√≠sticas de Fechas", fechas)
    print_group("Estad√≠sticas de Ubicaci√≥n", ubicacion)
    print_group("Procesamiento", processed)
    print_group("Arreglos y Listas", arrays)
    print_group("Otros", other)

    print_colored("\n" + "=" * 80, Fore.YELLOW)

def save_to_dat_file(stats, db_name, collection_name):
    """
    Guarda las estad√≠sticas en un archivo .dat.
    """
    current_date = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"{db_name}_{collection_name}_{current_date}.dat"
    try:
        with open(filename, 'w') as f:
            f.write(f"Estad√≠sticas Matem√°ticas Completas de la Colecci√≥n '{collection_name}'\n")
            f.write("=" * 80 + "\n")
            for key, value in stats.items():
                f.write(f"{key}: {value}\n")
            f.write("=" * 80 + "\n")
        print(f"Estad√≠sticas guardadas en {filename}")
    except Exception as e:
        print(f"Error guardando archivo: {e}")

def main():
    """
    Funci√≥n principal del script.
    """
    mongodb_uri = os.getenv('MONGODB_URI', 'mongodb://localhost:27017/')
    database_name = os.getenv('DATABASE_NAME', 'album')
    collection_name = os.getenv('COLLECTION_NAME', 'imagenes_2')

    collection = connect_to_mongodb()
    data = get_data(collection)
    df = convert_to_dataframe(data)
    stats = compute_statistics(df)
    print_statistics(stats, collection_name)
    save_to_dat_file(stats, database_name, collection_name)

if __name__ == "__main__":
    main()
</pre></div>
        </section>

        <section id="conclusion">
            <h2>9. Conclusi√≥n</h2>
            <p>Este sistema de organizaci√≥n de im√°genes proporciona una soluci√≥n completa para el procesamiento de grandes colecciones fotogr√°ficas. Siguiendo el orden establecido, se puede procesar autom√°ticamente todo el contenido, extraer metadatos valiosos y generar reportes estad√≠sticos detallados.</p>

            <p><strong>Recomendaciones:</strong></p>
            <ul>
                <li>Ejecutar los m√≥dulos en el orden establecido</li>
                <li>Verificar que MongoDB est√© funcionando antes de iniciar</li>
                <li>Hacer backup de la base de datos antes de procesamientos masivos</li>
                <li>Monitorizar el progreso de los scripts largos</li>
                <li>Usar variables de entorno para configuraciones personalizadas</li>
            </ul>
        </section>
    </div>

    <footer style="text-align: center; padding: 20px; margin-top: 40px; border-top: 3px solid #007cba;">
        <a href="pildoras.html">Pildoras T√©cnicas</a>
    </footer>

</body>
</html>
