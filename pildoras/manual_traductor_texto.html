<!DOCTYPE html>
<html lang="es" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manual de Empleo del Proyecto Traductor de Textos</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #212529; color: #f8f9fa; margin: 0; padding: 20px; }
        h1, h2, h3 { color: #ffffff; font-weight: 600; }
        pre { background-color: #495057; color: #f8f9fa; padding: 15px; border: none; border-radius: 0.375rem; overflow-x: auto; margin-bottom: 20px; font-size: 0.875rem; }
        code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; color: #f8f9fa; }
        ul, ol { margin-bottom: 20px; }
        .highlight { background-color: #495057; padding: 10px; border-radius: 0.375rem; }
        .container { max-width: 1200px; margin: 0 auto; }
        .card { background-color: #343a40; border: 1px solid #495057; border-radius: 0.375rem; margin-bottom: 20px; }
        .card-body { padding: 20px; }
    </style>
</head>
<body class="bg-dark text-light">
    <div class="container my-5">
        <h1 class="display-4 fw-bold text-center mb-5">Manual de Empleo del Proyecto Traductor de Textos</h1>

        <div class="alert alert-success mb-4" role="alert">
            <h4 class="alert-heading">üéØ Aplicaci√≥n Unificada Recomendada</h4>
            <p class="mb-0">Utilice <strong>traductor_documentos.py</strong> para una experiencia completa integrada con tres pesta√±as.</p>
        </div>

    <p>Este proyecto comprende un sistema completo de traducci√≥n autom√°tica que extrae texto de archivos, los segmenta en frases, los almacena en MongoDB y los traduce entre m√∫ltiples idiomas usando IA local. El proyecto ha evolucionado hacia una <strong>aplicaci√≥n unificada</strong> que integra todo el proceso en una interfaz gr√°fica intuitiva.</p>

    <h2>Estado Actual del Proyecto</h2>

    <h3>üèÜ Aplicaci√≥n Principal - traductor_documentos.py</h3>
    <ul>
        <li><strong>Aplicaci√≥n Completa Unificada</strong>: Una sola interfaz con tres pesta√±as que integra extracci√≥n, traducci√≥n y composici√≥n.</li>
        <li><strong>Soporte Multiidioma</strong>: Traducci√≥n entre espa√±ol, ingl√©s y franc√©s usando modelos Ollama avanzados.</li>
        <li><strong>Procesamiento As√≠ncrono</strong>: Arquitectura con hilos para mantener la interfaz responsiva.</li>
        <li><strong>Tema Oscuro Profesional</strong>: Interfaz moderna aplicada consistentemente.</li>
        <li><strong>Formatos Avanzados</strong>: Generaci√≥n autom√°tica de archivos .txt y PDF con formato tipogr√°fico.</li>
        <li><strong>Manejo de Errores Robusto</strong>: Sistema de recuperaci√≥n y cancelaci√≥n de operaciones.</li>
    </ul>

    <h3>üîß Scripts de Desarrollo y Debugging</h3>
    <p>Los scripts individuales representan la evoluci√≥n modular del proyecto:</p>

    <h4>Versiones CLI (L√≠nea de Comandos)</h4>
    <ul>
        <li><strong>debugeo/1-extraer_texto_a mongodb.py</strong>: Versi√≥n b√°sica CLI para extracci√≥n de texto.</li>
        <li><strong>debugeo/2-traducir_desde_mongodb.py</strong>: Versi√≥n b√°sica CLI para traducci√≥n.</li>
    </ul>

    <h4>Versiones GUI Modulares</h4>
    <ul>
        <li><strong>debugeo/1-extraer_texto_a mongodb_con_gui.py</strong>: GUI b√°sica para extracci√≥n con barra de progreso.</li>
        <li><strong>debugeo/2-traducir_desde_mongodb_con_gui.py</strong>: GUI avanzada para traducci√≥n masiva.</li>
        <li><strong>debugeo/3-componer.py</strong>: GUI para composici√≥n de archivos finales.</li>
    </ul>

    <p class="highlight"><strong>Evoluci√≥n del Proyecto</strong>: Los scripts en la carpeta <code>debugeo/</code> representan el desarrollo modular original que ha sido consolidado en la aplicaci√≥n unificada <code>traductor_documentos.py</code>. Estos scripts siguen siendo funcionales para desarrollo espec√≠fico y compatibilidad.</p>

    <h3>Arquitectura Evolutiva</h3>
    <div class="card mb-4">
        <div class="card-body">
            <h5 class="card-title">Del Desarrollo Modular a la Integraci√≥n Completa</h5>
            <p>El proyecto evolucion√≥ desde scripts separados hacia una <strong>aplicaci√≥n unificada</strong> que mantiene todas las funcionalidades pero ofrece una experiencia m√°s intuitiva:</p>
            <ol>
                <li><strong>Fase 1</strong>: Scripts CLI separados para funciones espec√≠ficas</li>
                <li><strong>Fase 2</strong>: Interfaces GUI individuales por cada funci√≥n</li>
                <li><strong>Fase 3</strong>: <strong>Aplicaci√≥n integrada con m√∫ltiples pesta√±as</strong> ‚≠ê</li>
            </ol>
        </div>
    </div>

    <h2>Explicaci√≥n Detallada de Cada Script</h2>

    <h3>Script 1: 1-extraer_texto_a mongodb.py</h3>
    <p>Este script se encarga de leer un archivo de texto y prepararlo para su procesamiento posterior. Espec√≠ficamente:</p>
    <ul>
        <li>Lee el contenido completo del archivo 'el_quijote.txt' (o el archivo especificado).</li>
        <li>Segmenta el texto en frases individuales separadas por puntos (.) y saltos de l√≠nea (\n).</li>
        <li>Conserva tanto el texto de las frases como los saltos de l√≠nea como segmentos independientes.</li>
        <li>Conecta a una base de datos MongoDB local y crea una colecci√≥n nombrada seg√∫n el archivo de entrada (sin extensi√≥n).</li>
        <li>Limpia la colecci√≥n existente para evitar duplicados antes de insertar nuevos datos.</li>
        <li>Almacena cada segmento como un documento con estructura {_id: n√∫mero_entero, linea: texto}.</li>
        <li>Muestra en consola cada segmento numerado para seguimiento.</li>
    </ul>

    <h3>Script 2: 2-traducir_desde_mongodb.py</h3>
    <p>Este script toma los datos preparados por el script anterior y los traduce usando inteligencia artificial. Realiza los siguientes pasos:</p>
    <ul>
        <li>Conecta a la misma base de datos MongoDB y lee todos los documentos de la colecci√≥n creada anteriormente.</li>
        <li>Para cada l√≠nea de texto, verifica si contiene contenido traducible (no est√° vac√≠a o solo contiene saltos de l√≠nea).</li>
        <li>Utiliza el servicio Ollama con el modelo 'gemma3:4b' para traducir cada l√≠nea del espa√±ol al ingl√©s.</li>
        <li>Maneja errores de traducci√≥n de forma individual, evitando que se detenga el proceso completo.</li>
        <li>Crea una nueva colecci√≥n en MongoDB con las traducciones, manteniendo la misma estructura de documentos.</li>
        <li>Para l√≠neas irrelevantes (vac√≠as o solo saltos de l√≠nea), guarda el contenido original sin traducir.</li>
        <li>Muestra el progreso en consola, incluyendo el texto original, la traducci√≥n generada y cualquier error encontrado.</li>
    </ul>

    <h3>Script GUI 1: 1-extraer_texto_a mongodb_con_gui.py</h3>
    <p>Esta aplicaci√≥n con interfaz gr√°fica permite una experiencia m√°s intuitiva para extraer texto a MongoDB:</p>
    <ul>
        <li>Interfaz gr√°fica construida con PySide6 para selecci√≥n manual de archivos de texto y PDF.</li>
        <li>Soporte m√∫ltiple de formatos: archivos .txt (texto plano) y .pdf (documentos PDF).</li>
        <li>Selecci√≥n de archivos mediante un di√°logo de archivos nativo del sistema operativo.</li>
        <li>Procesamiento en segundo plano usando hilos para evitar bloqueo de la interfaz.</li>
        <li>Barra de progreso visual que muestra el porcentaje de procesamiento completado.</li>
        <li>Bot√≥n de cancelaci√≥n para interrumpir el proceso en cualquier momento.</li>
        <li>Manejo de errores con mensajes informativos al usuario.</li>
        <li>Tema oscuro profesional para mayor comodidad visual.</li>
        <li>Validaci√≥n de archivos compatibles antes del procesamiento.</li>
        <li>Muestra el nombre del archivo seleccionado y mensajes de estado en tiempo real.</li>
    </ul>

    <h3>Script GUI 2: 2-traducir_desde_mongodb_con_gui.py</h3>
    <p>Interfaz avanzada para traducci√≥n masiva y gesti√≥n de colecciones:</p>
    <ul>
        <li>Detecci√≥n autom√°tica de todas las colecciones originales disponibles en MongoDB.</li>
        <li>Selecci√≥n m√∫ltiple de colecciones para traducci√≥n simult√°nea.</li>
        <li>Splitter interfaz dividida: panel lateral para selecci√≥n, panel derecho para controles y progreso.</li>
        <li>Registro de actividad detallado con colores diferenciados por tipo de mensaje (√©xito, error, informaci√≥n, etc.).</li>
        <li>Limpieza autom√°tica de colecciones destino antes de iniciar nuevas traducciones.</li>
        <li>Procesamiento en hilos separados para mantener la interfaz responsiva durante operaciones largas.</li>
        <li>Progreso global y por colecci√≥n, con manejo inteligente de errores por l√≠nea.</li>
        <li>Tema oscuro completo aplicado a toda la aplicaci√≥n usando paleta de colores Qt.</li>
        <li>Manejo de conexi√≥n a MongoDB con verificaci√≥n inicial y mensajes de diagn√≥stico.</li>
        <li>Opci√≥n de seleccionar todo o limpiar selecci√≥n de colecciones de forma r√°pida.</li>
    </ul>

    <h3>Script 3: 3-componer.py</h3>
    <p>Esta aplicaci√≥n gr√°fica permite componer textos finales desde las colecciones traducidas almacenadas en MongoDB:</p>
    <ul>
        <li>Detecci√≥n autom√°tica de colecciones que contienen "_traducido_" en su nombre.</li>
        <li>Selecci√≥n m√∫ltiple de colecciones para procesamiento simult√°neo.</li>
        <li>Generaci√≥n de archivos de texto plano con el contenido reconstruido.</li>
        <li>Opci√≥n adicional para exportar tambi√©n a formato PDF usando ReportLab.</li>
        <li>Procesamiento en hilos separados para evitar bloqueo de la interfaz.</li>
        <li>Barra de progreso global para el seguimiento de la operaci√≥n.</li>
        <li>Registro de actividad coloreado similar a las otras interfaces GUI.</li>
        <li>Tema oscuro profesional consistente.</li>
        <li>Manejo robusto de errores y posibilidad de cancelaci√≥n.</li>
        <li>Mantiene la estructura original del texto, conservando l√≠neas vac√≠as y saltos de l√≠nea.</li>
    </ul>

    <h2>Requisitos Previos</h2>
    <h3>Requisitos General</h3>
    <ul>
        <li>Python 3.x instalado.</li>
        <li>MongoDB corriendo localmente en mongodb://localhost:27017/.</li>
        <li>Ollama ejecut√°ndose en http://localhost:11434 con el modelo 'gemma3:4b' disponible.</li>
        <li>Archivo de texto de entrada (ej. 'el_quijote.txt') en el directorio del proyecto.</li>
    </ul>

    <h3>Dependencias para Versi√≥n CLI</h3>
    <ul>
        <li>Librer√≠a <strong>PyMongo</strong> instalada: <code>pip install pymongo</code></li>
        <li>Librer√≠a <strong>Requests</strong> instalada: <code>pip install requests</code></li>
    </ul>

    <h3>Dependencias para Versi√≥n GUI Unificada</h3>
    <ul>
        <li>Todas las dependencias de la versi√≥n CLI.</li>
        <li><strong>PySide6</strong>: <code>pip install PySide6</code> (recomendado) √≥ <strong>PyQt6</strong>: <code>pip install PyQt6</code></li>
        <li><strong>ReportLab</strong> (para generaci√≥n PDF): <code>pip install reportlab</code></li>
        <li><strong>PyPDF2</strong> (para lectura PDF): <code>pip install PyPDF2</code></li>
        <li><strong>Instalaci√≥n completa recomendada</strong>: <code>pip install pymongo requests PySide6 PyPDF2 reportlab</code></li>
    </ul>

    <div class="alert alert-info">
        <h5>‚ö†Ô∏è Nota sobre dependencias</h5>
        <p><strong>Para la aplicaci√≥n unificada</strong>: Solo necesitas la instalaci√≥n completa una vez. Para los scripts individuales de <code>debugeo/</code>, las dependencias var√≠an seg√∫n la funcionalidad espec√≠fica.</p>
    </div>

    <h2>C√≥mo Ejecutar el Proyecto</h2>

    <h3>üèÜ Aplicaci√≥n Unificada Recomendada (Opci√≥n M√°s Simple)</h3>
    <div class="card mb-4">
        <div class="card-body">
            <h5 class="card-title">Ejecuci√≥n con traductor_documentos.py</h5>
            <p class="card-text">La aplicaci√≥n m√°s sencilla y completa para usar el proyecto.</p>
            <ol>
                <li><strong>Instala dependencias</strong>: <code>pip install pymongo requests PySide6 PyPDF2 reportlab</code></li>
                <li><strong>Ejecuta la aplicaci√≥n</strong>:</li>
                <pre><code>python traductor_documentos.py</code></pre>
                <li><strong>Flujo de uso t√≠pico</strong>:
                    <br>‚Ä¢ <em>Pesta√±a 1 - Extraer</em>: Selecciona archivo .txt o .pdf
                    <br>‚Ä¢ <em>Pesta√±a 2 - Traducir</em>: Elige idiomas y colecciones
                    <br>‚Ä¢ <em>Pesta√±a 3 - Componer</em>: Genera archivos finales .txt y .pdf
                </li>
            </ol>
            <div class="alert alert-info">
                <strong>‚úÖ Ventajas</strong>: Una sola aplicaci√≥n para todo el proceso, interfaz intuitiva con tres pesta√±as, proceso completo con barras de progreso individuales.
            </div>
        </div>
    </div>

    <h3>Ejecuci√≥n con Versi√≥n CLI</h3>
    <ol>
        <li>Aseg√∫rate de que MongoDB est√© corriendo.</li>
        <li>Verifica que Ollama est√© ejecut√°ndose con el modelo correcto.</li>
        <li>Ejecuta el primer script de extracci√≥n:</li>
        <pre><code>python debugeo/1-extraer_texto_a mongodb.py</code></pre>
        <li>Ejecuta el segundo script de traducci√≥n:</li>
        <pre><code>python debugeo/2-traducir_desde_mongodb.py</code></pre>
    </ol>

    <h3>Ejecuci√≥n con Scripts GUI Independientes</h3>
    <ol>
        <li>Aseg√∫rate de que est√©n cumplidos todos los requisitos previos (incluyendo PySide6).</li>
        <li>Ejecuta la aplicaci√≥n de extracci√≥n GUI:</li>
        <pre><code>python debugeo/1-extraer_texto_a mongodb_con_gui.py</code></pre>
        <li>Clic en "Seleccionar archivo" y elige el archivo de texto deseado.</li>
        <li>Clic en "Procesar" y observa la barra de progreso.</li>
        <li>Ejecuta la aplicaci√≥n de traducci√≥n GUI:</li>
        <pre><code>python debugeo/2-traducir_desde_mongodb_con_gui.py</code></pre>
        <li>Selecciona las colecciones que deseas traducir usando el checkbox o "Seleccionar Todo".</li>
        <li>Clic en "Iniciar Traducci√≥n" y observa el registro de actividad y progreso.</li>
        <li>La interfaz GUI permite cancelar operaciones en cualquier momento.</li>
        <li>Ejecuta la aplicaci√≥n de composici√≥n GUI:</li>
        <pre><code>python debugeo/3-componer.py

# Para modo de diagn√≥stico/prueba (consola):
python debugeo/3-componer.py --test</code></pre>
        <li>Clic en "Actualizar Lista" para obtener las colecciones traducidas.</li>
        <li>Selecciona las colecciones a procesar usando checkboxes.</li>
        <li>Opcionalmente, marca "Exportar tambi√©n a PDF" para generar PDF adem√°s de texto.</li>
        <li>Clic en "Procesar Seleccionadas" y observa el progreso y registro.</li>
        <li>El modo --test permite verificar conexiones y contenido sin interfaz gr√°fica.</li>
    </ol>

    <div class="alert alert-warning">
        <h4>‚ÑπÔ∏è Sobre los Scripts en la Carpeta debugeo/</h4>
        <p>Los archivos en <code>debugeo/</code> son versiones individuales que precedieron a la aplicaci√≥n unificada. Son √∫tiles para desarrollo espec√≠fico pero requieren ejecutar m√∫ltiples scripts por separado. Se mantienen por compatibilidad y debugging avanzado.</p>
    </div>

    <p class="highlight">Nota importante: El orden de ejecuci√≥n es cr√≠tico. Siempre ejecuta primero la extracci√≥n antes de la traducci√≥n, ya sea en versi√≥n CLI o GUI. Los scripts segmentan el texto conservando saltos de l√≠nea y puntos, mientras que los scripts de traducci√≥n procesan l√≠neas vac√≠as eficientemente.</p>

    <h2>Configuraci√≥n de MongoDB</h2>
    <ul>
        <li><strong>Base de datos</strong>: traducciones (con variaciones: 'traducciones', 'traducir', 'translations')</li>
        <li><strong>Colecci√≥n origen</strong>: el_quijote (ajustable en COLECCION_NAME para CLI) / din√°mica para GUI</li>
        <li><strong>Colecci√≥n destino</strong>: [colecci√≥n_original]_traducido_al_ingles</li>
        <li><strong>Estructura de documentos</strong>: {"_id": int, "linea": str}</li>
    </ul>

    <div class="highlight">
    <strong>Nota sobre bases de datos:</strong> Los scripts detectan autom√°ticamente varias variaciones del nombre de base de datos ('traducciones', 'traducir', 'translations') para mayor compatibilidad.
    </div>

    <h2>C√≥digo de la Aplicaci√≥n Unificada - traductor_documentos.py</h2>

    <div class="alert alert-info mb-4">
        <h4>üìã Arquitectura de la Aplicaci√≥n Unificada</h4>
        <p>La aplicaci√≥n <code>traductor_documentos.py</code> integra tres componentes principales en una sola interfaz:</p>
    </div>

    <h3>üèóÔ∏è Componentes Principales</h3>

    <h4>1. Pesta√±a de Extracci√≥n (ExtractionWorker)</h4>
    <ul>
        <li><strong>Funcionalidad</strong>: Lee archivos .txt y .pdf, los segmenta por l√≠neas y los almacena en MongoDB</li>
        <li><strong>Soporte multi-formato</strong>: Compatible con texto plano (.txt) y archivos PDF (.pdf)</li>
        <li><strong>Procesamiento en hilos</strong>: Mantiene la interfaz responsiva durante operaciones largas</li>
        <li><strong>Barra de progreso</strong>: Seguimiento visual del procesamiento en tiempo real</li>
        <li><strong>Validaci√≥n inteligente</strong>: Verificaci√≥n de tipos de archivo y conexiones</li>
    </ul>

    <h4>2. Pesta√±a de Traducci√≥n (TranslationWorker)</h4>
    <ul>
        <li><strong>IA Avanzada</strong>: Utiliza Ollama con modelos como 'gemma3:4b' para traducciones de calidad</li>
        <li><strong>Soporte multiidioma</strong>: Espa√±ol ‚Üî Ingl√©s ‚Üî Franc√©s con prompts optimizados</li>
        <li><strong>Manejo robusto de errores</strong>: Contin√∫a procesamiento ante fallos individuales por l√≠nea</li>
        <li><strong>Procesamiento por lotes</strong>: Traduce m√∫ltiples colecciones simult√°neamente</li>
        <li><strong>Registro detallado</strong>: Seguimiento de cada traducci√≥n con estad√≠sticas en tiempo real</li>
        <li><strong>Cancelaci√≥n segura</strong>: Posibilidad de detener procesos largos sin perder datos</li>
    </ul>

    <h4>3. Pesta√±a de Composici√≥n (CompositionWorker)</h4>
    <ul>
        <li><strong>Reconstrucci√≥n inteligente</strong>: Junta textos traducidos respetando estructura original</li>
        <li><strong>Formatos m√∫ltiples</strong>: Genera archivos .txt y .pdf autom√°ticamente</li>
        <li><strong>PDF profesional</strong>: Crea documentos con formato tipogr√°fico usando ReportLab</li>
        <li><strong>Preservaci√≥n de contenido</strong>: Mantiene saltos de l√≠nea y estructura del documento original</li>
        <li><strong>Procesamiento masivo</strong>: Maneja m√∫ltiples colecciones traducidas simult√°neamente</li>
    </ul>

    <h3>üé® Caracter√≠sticas T√©cnicas Avanzadas</h3>

    <h4>Arquitectura con Hilos (QThread)</h4>
    <div class="card mb-3">
        <div class="card-body">
            <h5 class="card-title">Procesamiento As√≠ncrono</h5>
            <ul class="mb-0">
                <li>Cada operaci√≥n cr√≠tica se ejecuta en hilos separados</li>
                <li>Interfaz permanece responsiva durante operaciones largas</li>
                <li>Cantidad controlada de hilos para optimizar rendimiento</li>
                <li>Comunicaci√≥n segura entre hilos usando se√±ales Qt</li>
            </ul>
        </div>
    </div>

    <h4>Tema Oscuro Profesional</h4>
    <div class="card mb-3">
        <div class="card-body">
            <h5 class="card-title">Interfaz Moderna y Consistente</h5>
            <ul class="mb-0">
                <li>Paleta de colores oscura aplicada globalmente</li>
                <li>Estilos consistentes para todos los widgets PySide6</li>
                <li>Animaciones sutiles y transiciones suaves</li>
                <li>Optimizaci√≥n visual para uso prolongado</li>
            </ul>
        </div>
    </div>

    <h4>Gesti√≥n Completa de Conexiones</h4>
    <div class="card mb-3">
        <div class="card-body">
            <h5 class="card-title">Bases de Datos y Servicios Externos</h5>
            <ul class="mb-0">
                <li><strong>MongoDB</strong>: Conexi√≥n autom√°tica con detecci√≥n de bases de datos variantes</li>
                <li><strong>Ollama</strong>: Verificaci√≥n de conectividad y modelos disponibles</li>
                <li><strong>Control de errores</strong>: Manejo espec√≠fico para cada tipo de conexi√≥n</li>
                <li><strong>Recuperaci√≥n autom√°tica</strong>: Intentos de reconexi√≥n ante fallos temporales</li>
            </ul>
        </div>
    </div>

    <h3>üöÄ Ejecuci√≥n Simplificada</h3>

    <div class="card mb-4">
        <div class="card-body">
            <h5 class="card-title">Comando Principal</h5>
            <pre><code>python traductor_documentos.py</code></pre>

            <h6 class="mt-3">Flujo de Uso T√≠pico:</h6>
            <ol>
                <li><strong>Iniciar aplicaci√≥n</strong>: Se abre interfaz con tres pesta√±as</li>
                <li><strong>Pesta√±a 1 - Extraer</strong>: Seleccionar archivo (.txt o .pdf) y procesar</li>
                <li><strong>Pesta√±a 2 - Traducir</strong>: Elegir colecciones e idiomas de destino</li>
                <li><strong>Pesta√±a 3 - Componer</strong>: Generar archivos finales (.txt y .pdf)</li>
            </ol>
        </div>
    </div>

    <h3>‚öôÔ∏è Configuraci√≥n Global</h3>

    <div class="card mb-4">
        <div class="card-body">
            <h5 class="card-title">Constantes Principales</h5>
            <pre><code class="language-python"># Configuraci√≥n principal
DATABASE_NAME = "traducciones"
OLLAMA_URL = "http://localhost:11434/api/generate"
MODEL_NAME = "gemma3:4b"

# Idiomas soportados
IDIOMA_CODES = ["es", "en", "fr"]
IDIOMA_NAMES = {
    "es": "Espa√±ol",
    "en": "English",
    "fr": "Fran√ßais"
}

# Configuraci√≥n MongoDB
MONGO_TIMEOUT = 5000
CONNECTION_RETRIES = 3</code></pre>
        </div>
    </div>

    <h3>üõ°Ô∏è Sistema de Manejo de Errores</h3>
    <ul>
        <li><strong>Validaci√≥n de conexiones</strong>: Verificaci√≥n previa de MongoDB y Ollama</li>
        <li><strong>Recuperaci√≥n autom√°tica</strong>: Contin√∫a procesamiento ante errores individuales</li>
        <li><strong>Mensajes informativos</strong>: Descripciones claras de problemas encontrados</li>
        <li><strong>Registro detallado</strong>: Seguimiento completo de operaciones y errores</li>
        <li><strong>Cancelaci√≥n segura</strong>: Posibilidad de detener procesos sin corromper datos</li>
    </ul>



    <h2>Soluci√≥n de Problemas</h2>

    <h3>Problemas Generales</h3>
    <ul>
        <li><strong>MongoDB no se conecta</strong>: Verifica que est√© corriendo en el puerto por defecto (27017). En algunas versiones de MongoDB, puede requerir instalaci√≥n espec√≠fica o ajustes de configuraci√≥n.</li>
        <li><strong>Ollama falla</strong>: Aseg√∫rate de que el modelo 'gemma3:4b' est√© descargado y el servidor est√© activo en http://localhost:11434. Ejecuta <code>ollama list</code> para verificar modelos disponibles.</li>
        <li><strong>Dependencias faltantes</strong>: Instala todas las dependencias con pip. Verifica versiones compatibles de bibliotecas.</li>
        <li><strong>Codificaci√≥n de archivos</strong>: Aseg√∫rate de que los archivos de texto est√©n en UTF-8 para evitar problemas de caracteres especiales.</li>
    </ul>

    <h3>Problemas Espec√≠ficos de GUI</h3>
    <ul>
        <li><strong>PySide6 no se encuentra</strong>: Instala con <code>pip install PySide6</code>. Si hay conflictos, considera usar PyQt6 o PyQt5, ajustando las importaciones.</li>
        <li><strong>La interfaz no responde</strong>: Las operaciones se ejecutan en hilos separados. Si se congela completamente, reinicia la aplicaci√≥n.</li>
        <li><strong>Error de Qt plugins</strong>: Puede requerir instalaci√≥n de bibliotecas adicionales en Linux (sudo apt install qt6-base-dev).</li>
        <li><strong>Archivo no encontrado</strong>: En la aplicaci√≥n GUI de extracci√≥n, usa el di√°logo de archivos para seleccionar archivos v√°lidos.</li>
        <li><strong>Colecciones no aparecen en GUI de traducci√≥n</strong>: Las colecciones deben existir en la base de datos 'traducciones' y no tener sufijo '_traducido_al_ingles'.</li>
        <li><strong>Colecciones no aparecen en composici√≥n</strong>: Las colecciones deben contener '_traducido_' en el nombre para ser detectadas por la interfaz de composici√≥n.</li>
    </ul>

    <h3>Errores Comunes</h3>
    <ul>
        <li><strong>"Connection refused"</strong>: Verifica que MongoDB y Ollama est√©n ejecut√°ndose.</li>
        <li><strong>"Module not found"</strong>: Instala el m√≥dulo faltante con pip.</li>
        <li><strong>Traducciones vac√≠as</strong>: Puede ser normal para l√≠neas con solo saltos de l√≠nea. Registra el registro de actividad en la GUI.</li>
        <li><strong>Proceso cancelado inesperadamente</strong>: En GUI, usa los botones de cancelaci√≥n apropiadamente.</li>
    </ul>

    <h2>C√≥digo Completo del Archivo traductor_documentos.py</h2>

    <div class="alert alert-info mb-4">
        <h4>üìÑ C√≥digo Python Formateado</h4>
        <p>Abajo se presenta el c√≥digo completo del archivo <code>traductor_documentos.py</code>, incluyendo la explicaci√≥n detallada de su funcionalidad.</p>
    </div>

    <pre><code class="language-python">"""
Traductor Completo: Extraer, Traducir y Componer en una sola interfaz GUI con PySide6.

Este script integra las funcionalidades de:
1. Extraer texto de archivos PDF/TXT y almacenarlo en MongoDB
2. Traducir colecciones de MongoDB utilizando Ollama
3. Componer archivos finales (TXT y PDF) desde las traducciones

Uso:
    python traductor_completo_gui.py

Dependencias:
    - pymongo: Para MongoDB
    - PySide6: Para la interfaz GUI
    - PyPDF2: Para leer PDFs
    - requests: Para API de Ollama
    - reportlab: Para generar PDFs
    - Ollama: Debe estar corriendo localmente en http://localhost:11434
"""
import sys
import os
from PySide6.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel,
                               QProgressBar, QTextEdit, QMessageBox, QFileDialog, QGroupBox,
                               QListWidget, QListWidgetItem, QComboBox, QCheckBox, QSplitter, QTabWidget, QLineEdit)
from PySide6.QtGui import QPalette, QColor, QFont
from PySide6.QtCore import QThread, Signal, QObject
import pymongo
import PyPDF2
import requests
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_JUSTIFY
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak


# Constantes
DATABASE_NAME = "traducciones"
OLLAMA_URL = "http://localhost:11434/api/generate"
MODEL_NAME = "gemma3:4b"

IDIOMA_CODES = ["es", "en", "fr"]
IDIOMA_NAMES = {
    "es": "Espa√±ol",
    "en": "English",
    "fr": "Fran√ßais"
}

IDIOMA_NAMES_PROMPT = {
    "es": "espa√±ol",
    "en": "ingl√©s",
    "fr": "franc√©s"
}

# Funciones auxiliares
def traducir_con_ollama(texto: str, idioma_origen: str, idioma_destino: str) -> str:
    """Traduce texto usando Ollama."""
    nombre_origen = IDIOMA_NAMES_PROMPT[idioma_origen]
    nombre_destino = IDIOMA_NAMES_PROMPT[idioma_destino]

    prompt = ""
    if idioma_origen == "es":
        prompt = f"Translate the following text from Spanish to {nombre_destino}. Provide only the {nombre_destino} translation, without explanations or additional modifications:\\n\\n{texto}"
    elif idioma_origen == "en":
        prompt = f"Translate the following text from English to {nombre_destino}. Provide only the {nombre_destino} translation, without explanations or additional modifications:\\n\\n{texto}"
    elif idioma_origen == "fr":
        prompt = f"Translate the following text from French to {nombre_destino}. Provide only the {nombre_destino} translation, without explanations or additional modifications:\\n\\n{texto}"

    payload = {
        "model": MODEL_NAME,
        "prompt": prompt,
        "stream": False
    }

    response = requests.post(OLLAMA_URL, json=payload)
    if response.status_code == 200:
        data = response.json()
        return data.get("response", "").strip()
    else:
        raise Exception(f"Error en petici√≥n Ollama: {response.status_code}")

def segmentar_frases(ruta_archivo: str):
    """Segmenta archivo PDF o TXT en l√≠neas."""
    frases = []
    contenido = ""

    ext = os.path.splitext(ruta_archivo)[1].lower()
    if ext == ".txt":
        with open(ruta_archivo, "r", encoding="utf-8") as f:
            contenido = f.read()
    elif ext == ".pdf":
        with open(ruta_archivo, "rb") as f:
            pdf_reader = PyPDF2.PdfReader(f)
            for page in pdf_reader.pages:
                contenido += (page.extract_text() or "") + "\\n"
    else:
        raise ValueError("Formato no soportado. Solo .txt y .pdf.")

    frases = contenido.split('\\n')
    return frases

# Hilos de trabajo
class ExtractionWorker(QObject):
    progress = Signal(int)
    log = Signal(str)
    finished = Signal(bool, str)

    def __init__(self, file_path):
        super().__init__()
        self.file_path = file_path
        self.cancelled = False

    def run(self):
        try:
            frases = segmentar_frases(self.file_path)

            client = pymongo.MongoClient()
            db = client[DATABASE_NAME]
            base = os.path.basename(self.file_path)
            coleccion_nombre = os.path.splitext(base)[0]
            coleccion = db[coleccion_nombre]
            coleccion.delete_many({})

            total = len(frases)
            for i, frase in enumerate(frases, 1):
                if self.cancelled:
                    client.close()
                    self.finished.emit(False, "Extracci√≥n cancelada.")
                    return
                coleccion.insert_one({"_id": i, "linea": frase})
                self.progress.emit(int((i / total) * 100))
                self.log.emit(f"L√≠nea {i} procesada.")

            client.close()
            self.finished.emit(True, f"Extracci√≥n completada. {total} l√≠neas guardadas en '{coleccion_nombre}'.")
        except Exception as e:
            self.finished.emit(False, f"Error extracci√≥n: {str(e)}")

    def cancel(self):
        self.cancelled = True

class TranslationWorker(QObject):
    progress = Signal(int)
    log = Signal(str)
    finished = Signal(bool, str)

    def __init__(self, collections, source_lang, target_lang):
        super().__init__()
        self.collections = collections
        self.source_lang = source_lang
        self.target_lang = target_lang
        self.cancelled = False

    def run(self):
        try:
            client = pymongo.MongoClient()
            db = client[DATABASE_NAME]
            total_collections = len(self.collections)
            processed = 0

            for collection_name in self.collections:
                if self.cancelled:
                    client.close()
                    self.finished.emit(False, "Traducci√≥n cancelada.")
                    return

                self.log.emit(f"Traduciendo colecci√≥n: {collection_name}")
                collection_origen = db[collection_name]
                collection_destino = db[f"{collection_name}_traducido_a_{self.target_lang}"]
                collection_destino.drop()

                total_docs = collection_origen.count_documents({})
                processed_docs = 0

                for documento in collection_origen.find():
                    if self.cancelled:
                        client.close()
                        self.finished.emit(False, "Traducci√≥n cancelada.")
                        return

                    linea_numero = documento["_id"]
                    linea_texto = documento["linea"]

                    if not linea_texto.strip():
                        collection_destino.insert_one({"_id": linea_numero, "linea": linea_texto})
                        processed_docs += 1
                        self.log.emit(f"L√≠nea {linea_numero}: SKIP (vac√≠a)")
                    else:
                        traduccion = traducir_con_ollama(linea_texto, self.source_lang, self.target_lang)
                        collection_destino.insert_one({"_id": linea_numero, "linea": traduccion})
                        processed_docs += 1
                        # Truncate long translations for display
                        display_traduccion = traduccion[:80] + "..." if len(traduccion) > 80 else traduccion
                        self.log.emit(f"L√≠nea {linea_numero}: '{display_traduccion}'")

                    collection_progress = int((processed_docs / total_docs) * 100) if total_docs > 0 else 100
                    overall_progress = int(((processed + collection_progress / 100) / total_collections) * 100)
                    self.progress.emit(overall_progress)

                processed += 1
                self.log.emit(f"Finalizada colecci√≥n {collection_name}")

            client.close()
            self.finished.emit(True, "Traducci√≥n completada.")
        except Exception as e:
            self.finished.emit(False, f"Error traducci√≥n: {str(e)}")

    def cancel(self):
        self.cancelled = True

class CompositionWorker(QObject):
    progress = Signal(int)
    log = Signal(str)
    finished = Signal(bool, str)

    def __init__(self, collections, save_dir, export_pdf):
        super().__init__()
        self.collections = collections
        self.save_dir = save_dir
        self.export_pdf = export_pdf
        self.cancelled = False

    def run(self):
        try:
            client = pymongo.MongoClient()
            db = client[DATABASE_NAME]
            total = len(self.collections)

            for i, coll_name in enumerate(self.collections, 1):
                if self.cancelled:
                    client.close()
                    self.finished.emit(False, "Composici√≥n cancelada.")
                    return

                self.log.emit(f"Procesando colecci√≥n: {coll_name}")
                collection = db[coll_name]
                all_docs = list(collection.find(sort=[("_id", 1)]))

                output_file = os.path.join(self.save_dir, f"{coll_name}.txt")
                try:
                    with open(output_file, 'w', encoding='utf-8') as f:
                        for doc in all_docs:
                            if self.cancelled:
                                client.close()
                                self.finished.emit(False, "Composici√≥n cancelada.")
                                return
                            if 'linea' in doc:
                                linea_content = str(doc['linea'])
                                f.write(linea_content + '\\n')
                    self.log.emit(f"Archivo TXT creado: {output_file}")
                except Exception as e:
                    self.log.emit(f"Error creando TXT '{output_file}': {str(e)}")
                    # continue to try PDF creation (or next collection)

                if self.export_pdf:
                    try:
                        pdf_file = os.path.join(self.save_dir, f"{coll_name}.pdf")

                        # Crear un estilo personalizado con justificaci√≥n (no sobrescribimos el stylesheet global)
                        styles = getSampleStyleSheet()
                        body_style = ParagraphStyle(
                            'CustomBody',
                            parent=styles['BodyText'],
                            fontName="Helvetica",
                            fontSize=12,
                            alignment=TA_JUSTIFY,
                            leading=14
                        )

                        # Funci√≥n para dibujar el n√∫mero de p√°gina en el footer
                        def draw_page_number(canvas, doc):
                            try:
                                canvas.setFont('Helvetica', 10)
                                page_num = canvas.getPageNumber()
                                text = f"P√°gina {page_num}"
                                canvas.drawRightString(letter[0] - 0.5 * inch, 0.75 * inch, text)
                            except Exception as e:
                                # Logger del hilo (no arrojar excepci√≥n a ReportLab)
                                self.log.emit(f"Error en draw_page_number: {str(e)}")

                        # Crear el documento con SimpleDocTemplate (callbacks se pasan a build)
                        pdf_template = SimpleDocTemplate(
                            pdf_file,
                            pagesize=letter,
                            leftMargin=0.5*inch,
                            rightMargin=0.5*inch,
                            topMargin=0.75*inch,
                            bottomMargin=1*inch
                        )

                        story = []

                        # Add some space at the top
                        story.append(Spacer(1, 0.25*inch))

                        num_paragraphs = 0
                        for doc in all_docs:
                            if 'linea' in doc:
                                linea_content = str(doc['linea']).strip()
                                if linea_content:
                                    p = Paragraph(linea_content, body_style)
                                    story.append(p)
                                    story.append(Spacer(1, 0.1*inch))
                                    num_paragraphs += 1

                        if num_paragraphs == 0:
                            # Agregar mensaje por defecto si no hay contenido
                            p = Paragraph("No hay contenido disponible.", body_style)
                            story.append(p)

                        self.log.emit(f"Preparado PDF con {num_paragraphs} p√°rrafos.")
                        self.log.emit(f"Generando PDF - export_pdf: {self.export_pdf}, len(story): {len(story)}")

                        # Aqu√≠ pasamos los callbacks a build (correcci√≥n clave)
                        pdf_template.build(story, onFirstPage=draw_page_number, onLaterPages=draw_page_number)

                        # Verificar que el archivo exista y tenga tama√±o
                        if os.path.exists(pdf_file) and os.path.getsize(pdf_file) > 0:
                            self.log.emit(f"Archivo PDF creado: {pdf_file}")
                        else:
                            self.log.emit(f"PDF creado pero est√° vac√≠o o no existe: {pdf_file}")

                    except Exception as e:
                        self.log.emit(f"Error generando PDF para '{coll_name}': {str(e)}")

                self.progress.emit(int((i / total) * 100))

            client.close()
            self.finished.emit(True, "Composici√≥n completada.")
        except Exception as e:
            self.finished.emit(False, f"Error composici√≥n: {str(e)}")

    def cancel(self):
        self.cancelled = True

# Main Window
class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Traductor Completo - Extraer, Traducir y Componer")
        self.setGeometry(100, 100, 900, 700)
        self.apply_dark_theme()
        self.setup_ui()
        self.connect_signals()
        self.load_collections()

    def apply_dark_theme(self):
        self.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                color: #ffffff;
                font-family: Arial, sans-serif;
            }
            QPushButton {
                background-color: #404040;
                color: #ffffff;
                border: 1px solid #606060;
                padding: 8px;
                border-radius: 4px;
                height: 35px;
            }
            QPushButton:hover {
                background-color: #505050;
            }
            QPushButton:pressed {
                background-color: #303030;
            }
            QPushButton:disabled {
                background-color: #303030;
                color: #666666;
            }
            QLabel {
                color: #ffffff;
                font-size: 12px;
            }
            QListWidget {
                background-color: #404040;
                color: #ffffff;
                border: 1px solid #606060;
                border-radius: 4px;
                selection-background-color: #4CAF50;
            }
            QTextEdit {
                background-color: #404040;
                color: #ffffff;
                border: 1px solid #606060;
                border-radius: 4px;
                font-family: 'Courier New', monospace;
                font-size: 11px;
            }
            QProgressBar {
                background-color: #404040;
                border: 1px solid #606060;
                border-radius: 4px;
                text-align: center;
            }
            QProgressBar::chunk {
                background-color: #4CAF50;
            }
            QComboBox {
                background-color: #404040;
                color: #ffffff;
                border: 1px solid #606060;
                border-radius: 4px;
                padding: 4px;
            }
            QLineEdit, QCheckBox {
                color: #ffffff;
                font-size: 12px;
            }
            QCheckBox::indicator {
                width: 15px;
                height: 15px;
                border: 1px solid #606060;
                background-color: #404040;
            }
            QCheckBox::indicator:checked {
                background-color: #4CAF50;
            }
            QGroupBox {
                color: #ffffff;
                font-weight: bold;
                border: 2px solid #606060;
                border-radius: 5px;
                margin-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
        """)

    def setup_ui(self):
        main_layout = QVBoxLayout()

        # Tabs
        self.tab_widget = QTabWidget()
        self.tab_widget.addTab(self.setup_extraction_tab(), "1. Extraer Texto")
        self.tab_widget.addTab(self.setup_translation_tab(), "2. Traducir")
        self.tab_widget.addTab(self.setup_composition_tab(), "3. Componer Archivos TXT y PDF")

        main_layout.addWidget(self.tab_widget)

        # Global progress and log
        self.progress_group = QGroupBox("Progreso Global")
        progress_layout = QVBoxLayout()
        self.global_progress = QProgressBar()
        self.global_progress.setRange(0, 100)
        self.global_progress.setValue(0)
        progress_layout.addWidget(self.global_progress)

        self.log_group = QGroupBox("Registro de Actividad")
        log_layout = QVBoxLayout()
        self.log_text = QTextEdit()
        log_layout.addWidget(self.log_text)

        main_layout.addWidget(self.progress_group)
        main_layout.addWidget(self.log_group)

        self.setLayout(main_layout)

        self.worker = None
        self.thread = None

    def setup_extraction_tab(self):
        tab = QWidget()
        layout = QVBoxLayout()

        # File selection
        file_group = QGroupBox("Seleccionar Archivo")
        file_layout = QVBoxLayout()
        self.extraction_file_label = QLabel("Archivo seleccionado: Ninguno")
        self.select_file_btn = QPushButton("Seleccionar Archivo (TXT/PDF)")
        file_layout.addWidget(self.extraction_file_label)
        file_layout.addWidget(self.select_file_btn)
        file_group.setLayout(file_layout)

        # Controls
        controls_group = QGroupBox("Controles")
        controls_layout = QVBoxLayout()
        self.extract_btn = QPushButton("Extraer Texto")
        self.extract_btn.setEnabled(False)
        controls_layout.addWidget(self.extract_btn)
        controls_group.setLayout(controls_layout)

        layout.addWidget(file_group)
        layout.addWidget(controls_group)
        layout.addStretch()

        tab.setLayout(layout)
        return tab

    def setup_translation_tab(self):
        tab = QWidget()
        layout = QVBoxLayout()

        # Collections
        collections_group = QGroupBox("Colecciones por Traducir")
        collections_layout = QVBoxLayout()
        self.translation_list = QListWidget()
        self.translation_list.setSelectionMode(QListWidget.MultiSelection)
        self.refresh_btn = QPushButton("Actualizar Colecciones")
        collections_layout.addWidget(self.translation_list)
        collections_layout.addWidget(self.refresh_btn)
        collections_group.setLayout(collections_layout)

        # Language selection
        language_group = QGroupBox("Idiomas")
        language_layout = QVBoxLayout()
        source_layout = QHBoxLayout()
        source_layout.addWidget(QLabel("Desde:"))
        self.source_combo = QComboBox()
        self.source_combo.addItems([f"{code} - {name}" for code, name in IDIOMA_NAMES.items()])
        self.source_combo.setCurrentIndex(0)
        source_layout.addWidget(self.source_combo)

        target_layout = QHBoxLayout()
        target_layout.addWidget(QLabel("Hasta:"))
        self.target_combo = QComboBox()
        self.target_combo.addItems([f"{code} - {name}" for code, name in IDIOMA_NAMES.items()])
        self.target_combo.setCurrentIndex(1)
        target_layout.addWidget(self.target_combo)

        language_layout.addLayout(source_layout)
        language_layout.addLayout(target_layout)
        language_group.setLayout(language_layout)

        # Controls
        controls_group = QGroupBox("Controles")
        controls_layout = QVBoxLayout()
        self.translate_btn = QPushButton("Traducir Seleccionadas")
        self.translate_btn.setEnabled(False)
        self.translate_cancel_btn = QPushButton("Cancelar")
        self.translate_cancel_btn.setEnabled(False)
        controls_layout.addWidget(self.translate_btn)
        controls_layout.addWidget(self.translate_cancel_btn)
        controls_group.setLayout(controls_layout)

        # Translation Progress and Log
        progress_group = QGroupBox("Progreso de Traducci√≥n")
        progress_layout = QVBoxLayout()
        self.translation_progress = QProgressBar()
        self.translation_progress.setRange(0, 100)
        self.translation_progress.setValue(0)
        progress_layout.addWidget(self.translation_progress)

        translation_log_label = QLabel("Registro de Traducci√≥n:")
        self.translation_log = QTextEdit()
        self.translation_log.setMaximumHeight(300)
        self.translation_log.setFont(QFont("Monospace", 9))
        self.translation_log.setReadOnly(True)
        progress_layout.addWidget(translation_log_label)
        progress_layout.addWidget(self.translation_log)

        progress_group.setLayout(progress_layout)

        layout.addWidget(collections_group)
        layout.addWidget(language_group)
        layout.addWidget(controls_group)
        layout.addWidget(progress_group)

        tab.setLayout(layout)
        return tab

    def setup_composition_tab(self):
        tab = QWidget()
        layout = QVBoxLayout()

        # Collections
        collections_group = QGroupBox("Colecciones Traducidas")
        collections_layout = QVBoxLayout()
        self.composition_list = QListWidget()
        self.composition_list.setSelectionMode(QListWidget.MultiSelection)
        self.refresh_translation_btn = QPushButton("Actualizar Colecciones Traducidas")
        collections_layout.addWidget(self.composition_list)
        collections_layout.addWidget(self.refresh_translation_btn)
        collections_group.setLayout(collections_layout)

        # Controls
        controls_group = QGroupBox("Controles")
        controls_layout = QVBoxLayout()
        self.compose_btn = QPushButton("Componer Archivos TXT y PDF")
        self.compose_btn.setEnabled(False)
        controls_layout.addWidget(self.compose_btn)
        controls_group.setLayout(controls_layout)

        layout.addWidget(collections_group)
        layout.addWidget(controls_group)
        layout.addStretch()

        tab.setLayout(layout)
        return tab

    def connect_signals(self):
        # Extraction
        self.select_file_btn.clicked.connect(self.select_file)
        self.extract_btn.clicked.connect(self.start_extraction)

        # Translation
        self.refresh_btn.clicked.connect(self.load_collections)
        self.translate_btn.clicked.connect(self.start_translation)
        self.translate_cancel_btn.clicked.connect(self.cancel_translation)

        # Composition
        self.refresh_translation_btn.clicked.connect(self.load_translated_collections)
        self.compose_btn.clicked.connect(self.start_composition)

    def select_file(self):
        file_path, _ = QFileDialog.getOpenFileName(self, "Seleccionar archivo", "", "Archivos de texto (*.txt);;PDF (*.pdf)")
        if file_path:
            self.extraction_file_path = file_path
            self.extraction_file_label.setText(f"Archivo seleccionado: {os.path.basename(file_path)}")
            self.extract_btn.setEnabled(True)
            self.log("Archivo seleccionado: " + os.path.basename(file_path))
        else:
            self.extract_btn.setEnabled(False)
            self.extraction_file_label.setText("Archivo seleccionado: Ninguno")

    def load_collections(self):
        try:
            client = pymongo.MongoClient()
            db = client[DATABASE_NAME]
            collections = db.list_collection_names()

            # Filter original collections (no translated ones)
            known_suffixes = [f"_traducido_a_{lang}" for lang in IDIOMA_CODES]
            original_collections = [coll for coll in collections if not any(coll.endswith(suf) for suf in known_suffixes)]

            self.translation_list.clear()
            for coll in sorted(original_collections):
                item = QListWidgetItem(coll)
                self.translation_list.addItem(item)

            if original_collections:
                self.translate_btn.setEnabled(True)
            else:
                self.translate_btn.setEnabled(False)

            client.close()
            self.log(f"Colecciones cargadas: {len(original_collections)} originales")
        except Exception as e:
            QMessageBox.warning(self, "Error", f"No se pudo cargar colecciones: {str(e)}")

    def load_translated_collections(self):
        try:
            client = pymongo.MongoClient()
            db = client[DATABASE_NAME]
            collections = db.list_collection_names()

            # Filter translated collections
            translated_collections = [coll for coll in collections if '_traducido_' in coll]

            self.composition_list.clear()
            for coll in sorted(translated_collections):
                item = QListWidgetItem(coll)
                self.composition_list.addItem(item)

            if translated_collections:
                self.compose_btn.setEnabled(True)
            else:
                self.compose_btn.setEnabled(False)

            client.close()
            self.log(f"Colecciones traducidas cargadas: {len(translated_collections)}")
        except Exception as e:
            QMessageBox.warning(self, "Error", f"No se pudo cargar colecciones traducidas: {str(e)}")

    def check_ollama_connection(self):
        """Simple check for Ollama connection"""
        try:
            payload = {
                "model": MODEL_NAME,
                "prompt": "Hello",
                "stream": False
            }
            response = requests.post(OLLAMA_URL, json=payload, timeout=5)
            return response.status_code == 200
        except:
            return False

    def start_extraction(self):
        if not hasattr(self, 'extraction_file_path'):
            QMessageBox.warning(self, "Error", "Seleccione un archivo primero.")
            return

        # Check if thread is running
        if self.thread and self.thread.isRunning():
            return

        self.worker = ExtractionWorker(self.extraction_file_path)
        self.worker.progress.connect(self.global_progress.setValue)
        self.worker.log.connect(self.log)
        self.worker.finished.connect(self.on_worker_finished)

        from PySide6.QtCore import QThread
        self.thread = QThread()
        self.worker.moveToThread(self.thread)
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)

        self.extract_btn.setText("Extrayendo...")
        self.extract_btn.setEnabled(False)
        self.thread.start()

    def start_translation(self):
        selected_items = self.translation_list.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "Error", "Seleccione al menos una colecci√≥n.")
            return

        if not self.check_ollama_connection():
            QMessageBox.warning(self, "Error", "No se puede conectar a Ollama. Aseg√∫rese de que est√© ejecut√°ndose.")
            return

        collections = [item.text() for item in selected_items]
        source_idx = self.source_combo.currentIndex()
        target_idx = self.target_combo.currentIndex()
        source_lang = IDIOMA_CODES[source_idx]
        target_lang = IDIOMA_CODES[target_idx]

        if source_lang == target_lang:
            QMessageBox.warning(self, "Error", "Los idiomas deben ser diferentes.")
            return

        # Check if thread is running
        if self.thread and self.thread.isRunning():
            return

        self.worker = TranslationWorker(collections, source_lang, target_lang)
        self.worker.progress.connect(self.global_progress.setValue)
        self.worker.progress.connect(self.translation_progress.setValue)
        self.worker.log.connect(self.log)
        self.worker.log.connect(self.log_translation)
        self.worker.finished.connect(self.on_worker_finished)

        from PySide6.QtCore import QThread
        self.thread = QThread()
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)

        # Clear translation log and reset progress
        self.translation_log.clear()
        self.translation_progress.setValue(0)

        self.translate_btn.setText("Traduciendo...")
        self.translate_btn.setEnabled(False)
        self.translate_cancel_btn.setText("Cancelar")
        self.translate_cancel_btn.setEnabled(True)
        self.thread.start()

    def cancel_translation(self):
        if self.worker and isinstance(self.worker, TranslationWorker) and self.thread and self.thread.isRunning():
            self.worker.cancel()
            self.translate_cancel_btn.setText("Cancelando...")
            self.translate_cancel_btn.setEnabled(False)
            self.log("Progreso de traducci√≥n cancelado por el usuario.")

    def start_composition(self):
        selected_items = self.composition_list.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "Error", "Seleccione al menos una colecci√≥n.")
            return

        collections = [item.text() for item in selected_items]
        save_dir = QFileDialog.getExistingDirectory(self, "Seleccionar directorio para guardar archivos")
        if not save_dir:
            save_dir = os.getcwd()

        # Check if thread is running
        if self.thread and self.thread.isRunning():
            return

        self.worker = CompositionWorker(collections, save_dir, True)
        self.worker.progress.connect(self.global_progress.setValue)
        self.worker.log.connect(self.log)
        self.worker.finished.connect(self.on_worker_finished)

        from PySide6.QtCore import QThread
        self.thread = QThread()
        self.worker.moveToThread(self.thread)
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)

        self.compose_btn.setText("Componiendo...")
        self.compose_btn.setEnabled(False)
        self.thread.start()

    def on_worker_finished(self, success, message):
        self.global_progress.setValue(100 if success else 0)
        self.log(message)

        # Reset buttons
        self.extract_btn.setText("Extraer Texto")
        self.extract_btn.setEnabled(True)
        self.translate_btn.setText("Traducir Seleccionadas")
        self.translate_btn.setEnabled(True)
        self.translate_cancel_btn.setText("Cancelar")
        self.translate_cancel_btn.setEnabled(False)
        self.compose_btn.setText("Componer Archivos")
        self.compose_btn.setEnabled(True)

        if self.thread:
            self.thread.quit()
            self.thread.wait()

        if success:
            QMessageBox.information(self, "√âxito", message)
        else:
            QMessageBox.warning(self, "Error", message)

        # Refresh collections if needed
        self.load_collections()
        self.load_translated_collections()

        # Reset worker and thread
        self.worker = None
        self.thread = None

    def log(self, message):
        self.log_text.append(message)
        # Auto-scroll to bottom
        scrollbar = self.log_text.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())

    def log_translation(self, message):
        self.translation_log.append(message)
        # Auto-scroll to bottom
        scrollbar = self.translation_log.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())
</code></pre>

    <div class="alert alert-success mt-4">
        <h4>üìã Explicaci√≥n de la Funcionalidad</h4>
        <p>El c√≥digo anterior representa una aplicaci√≥n completa de traducci√≥n autom√°tica:

        <h5>1. Arquitectura General</h5>
        <ul>
            <li><strong>Interfaz Unificada</strong>: Integra tres pesta√±as en una sola aplicaci√≥n</li>
            <li><strong>Procesamiento As√≠ncrono</strong>: Usa QThread para mantener la responsividad de la GUI</li>
            <li><strong>Tema Oscuro</strong>: Aplicado globalmente con estilos CSS personalizados</li>
        </ul>

        <h5>2. Funciones Core</h5>
        <ul>
            <li><strong>segmentar_frases()</strong>: Procesa archivos .txt y .pdf, extrayendo contenido por l√≠neas</li>
            <li><strong>traducir_con_ollama()</strong>: Interfaz con servicio Ollama para traducciones</li>
        </ul>

        <h5>3. Worker Classes</h5>
        <ul>
            <li><strong>ExtractionWorker</strong>: Extrae texto de archivos y lo almacena en MongoDB</li>
            <li><strong>TranslationWorker</strong>: Traduce colecciones de MongoDB usando IA</li>
            <li><strong>CompositionWorker</strong>: Genera archivos .txt y .pdf finales</li>
        </ul>

        <h5>4. Soporte Multiidioma</h5>
        <p>Soporta espa√±ol, ingl√©s y franc√©s con prompts optimizados por idioma de origen.</p>

        <h5>5. Generaci√≥n de PDFs</h5>
        <p>Usa ReportLab para crear documentos justificados con n√∫meros de p√°gina autom√°ticos.</p>

        <p>Esta aplicaci√≥n es el resultado final de la evoluci√≥n del proyecto, consolidando m√≥dulos separados en una experiencia coherente.</p>
    </div>

    <h2>Contacto</h2>
    <p>Para m√°s informaci√≥n o soporte, visita <a href="https://bgonpin.github.io/" target="_blank" class="text-light">bgonpin.github.io</a>.</p>
    </div>  <!-- End of container -->
    <footer class="text-center py-3 bg-dark text-light mt-4">
        <a href="./pildoras.html" class="text-light">Ir a P√≠ldoras</a> | <a href="https://github.com/bgonpin/TRADUCTOR_ARCHIVOS" class="text-light" target="_blank">Ver en GitHub</a>
    </footer>
</body>
</html>
